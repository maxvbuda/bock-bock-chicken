<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chicken Games</title>
  
  <!-- PostHog Analytics -->
  <script>
    !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.async=!0,p.src=s.api_host+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
    posthog.init('phc_sloVEwzIB8ds3BbJpYmgxRj36tofr4gVi4YcMnqikco',{api_host:'https://us.i.posthog.com'})
  </script>
  
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600;700&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  
  <style>
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    body {
      margin: 0;
      font-family: 'Poppins', 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      color: #333;
      text-align: center;
      animation: fadeIn 0.5s ease-out;
    }
    .top-menu {
      width: 100%;
      background: linear-gradient(to right, #fffdf7, #fff5e1);
      border-bottom: 3px solid #e6d1a3;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      backdrop-filter: blur(10px);
    }
    .top-menu ul {
      list-style: none;
      margin: 0;
      padding: 8px 0;
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .top-menu li {
      display: inline;
    }
    .top-menu a {
      display: inline-block;
      padding: 12px 24px;
      font-size: 1em;
      color: #fff;
      background: linear-gradient(135deg, #d97428 0%, #c96620 100%);
      border: none;
      border-radius: 12px;
      font-family: 'Quicksand', 'Georgia', serif;
      font-weight: 600;
      text-decoration: none;
      box-shadow: 0 4px 15px rgba(217, 116, 40, 0.3);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    .top-menu a::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.5s;
    }
    .top-menu a:hover::before {
      left: 100%;
    }
    .top-menu a:hover {
      background: linear-gradient(135deg, #a85c1a 0%, #8a4a15 100%);
      color: #ffe4b3;
      text-decoration: none;
      box-shadow: 0 6px 25px rgba(217, 116, 40, 0.4);
      transform: translateY(-2px);
    }
    .top-menu a.active {
      background: linear-gradient(135deg, #fffbe7 0%, #fff5d6 100%);
      color: #d97428;
      border: 2px solid #d97428;
      cursor: default;
      box-shadow: 0 4px 15px rgba(217, 116, 40, 0.2);
      pointer-events: none;
    }
    /* Game selector styles */
    .game-selector {
      margin: 30px auto;
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    .game-button {
      padding: 16px 36px;
      font-size: 1.2em;
      background: linear-gradient(135deg, #ffc04c 0%, #ffb033 100%);
      color: #543d2b;
      border: 2px solid #d97428;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
      box-shadow: 0 6px 20px rgba(255, 192, 76, 0.3);
    }
    .game-button:hover {
      background: linear-gradient(135deg, #ffd580 0%, #ffc04c 100%);
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(255, 192, 76, 0.4);
    }
    .game-button.active {
      background: linear-gradient(135deg, #d97428 0%, #c96620 100%);
      color: white;
      box-shadow: 0 8px 25px rgba(217, 116, 40, 0.4);
      transform: translateY(-2px);
    }
    .game-container {
      margin: 30px auto;
      position: relative;
      width: 800px;
      display: none; /* Initially hidden */
      visibility: hidden; /* Double protection against display issues */
    }
    #tower-defense-canvas {
      background-color: #a1c181; /* Grassy green */
      border: 2px solid #543d2b; /* Dark brown */
    }
    #pacman-canvas {
      background-color: #000000; /* Black background for classic Pac-Man */
      border: 2px solid #1919A6; /* Blue border for classic Pac-Man */
    }
    .start-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      font-size: 2em;
      padding: 20px 40px;
      cursor: pointer;
      background: #5a9a5a;
      color: white;
      border: none;
      border-radius: 10px;
    }
    #pacman-start-button {
      background: #1919A6; /* Blue for Pac-Man */
    }
    
    .canvas-container {
      position: relative;
      margin: 0 auto;
      width: fit-content;
    }
    
    /* Specific margin only for the Pac-Man container to accommodate virtual controls */
    #pacman-container .canvas-container {
      margin-bottom: 220px;
    }
    .game-stats {
      font-size: 1.2em;
      font-weight: bold;
      margin: 10px 0;
    }
    
    /* Virtual Arrow Keys Styles */
    .virtual-controls {
      display: none; /* Hidden by default on desktop */
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 200px;
      z-index: 1000; /* Ensure controls appear on top */
    }
    
    /* Ensure game containers are properly shown when active */
    .game-container.active {
      display: block !important;
      visibility: visible !important;
    }
    
    .arrow-key {
      position: absolute;
      width: 70px;
      height: 70px;
      background: rgba(255, 255, 255, 0.85);
      border: 3px solid #d97428;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      font-weight: bold;
      color: #d97428;
      user-select: none;
      -webkit-user-select: none;
      cursor: pointer;
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
      transition: background 0.2s, transform 0.1s;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }
    
    .arrow-key:active {
      background: rgba(255, 192, 76, 1.0);
      transform: scale(0.9);
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      border-color: #ff8c00;
    }
    
    .arrow-up {
      top: 0;
      left: 65px;
    }
    
    .arrow-left {
      top: 65px;
      left: 0;
    }
    
    .arrow-right {
      top: 65px;
      left: 130px;
    }
    
    .arrow-down {
      top: 130px;
      left: 65px;
    }
    #tower-info-bar {
      background: #fffbe7;
      padding: 15px;
      text-align: center;
      border-bottom: 2px solid #e6d1a3;
      font-size: 1.1em;
      color: #543d2b;
      min-height: 80px; /* Ensure it has a consistent height */
    }
    #tower-info-bar h3 {
      margin: 0 0 8px 0;
    }
    #tower-info-bar p {
      margin: 0;
    }
    
    /* Media queries for responsive design */
    @media (max-width: 960px) {
      .game-selector {
        flex-direction: column;
        align-items: center;
      }
    }
    
    /* Only show virtual controls on smaller screens (mobile devices) */
    @media (max-width: 768px) {      
      .canvas-container {
        margin-bottom: 220px; /* Add space for virtual controls */
      }
      
      /* Show virtual controls on mobile */
      .virtual-controls {
        display: block;
      }
      
      /* Make game canvas responsive on mobile */
      #pacman-canvas {
        max-width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <nav class="top-menu">
    <ul>
      <li><a href="index.html">The Cluckington Family</a></li>
      <li><a href="family-members.html">Family Members</a></li>
      <li><a href="golden-knight.html">The Golden Knight of Chickenopolis</a></li>
      <li><a href="homework.html">Homework Kanban</a></li>
      <li><a href="games.html" class="active">Games</a></li>
      <li><a href="sailing-data-tool.html">Wind Forecaster</a></li>
      <li><a href="teach-me-anything.html">Teach Me Anything</a></li>
      <li><a href="chat-with-peep.html">Chat with Sir Peepius</a></li>
      <li><a href="bedtime-stories.html">Bedtime Stories</a></li>
    </ul>
  </nav>
  <div id="tower-info-bar"></div>
  
  <h1>Chicken Games Arcade</h1>
  <div class="game-selector">
    <button class="game-button active" id="tower-defense-button">Tower Defense</button>
    <button class="game-button" id="pacman-button">Chicken Maze</button>
  </div>
  
  <!-- Tower Defense Game -->
  <div id="tower-defense-container" class="game-container active">
    <h2>Fox vs. Chicken Tower Defense</h2>
    <div class="game-stats" id="tower-defense-stats">
      <span>Money: <span id="money">150</span></span> |
      <span>Lives: <span id="lives">10</span></span> |
      <span>Wave: <span id="wave">0</span></span> |
      <span>Score: <span id="score">0</span></span>
    </div>
    <div class="canvas-container" style="margin-bottom: 20px; position: relative;"> <!-- Override the large margin and add relative positioning -->
      <canvas id="tower-defense-canvas" width="800" height="600"></canvas>
      <button class="start-button" id="tower-defense-start-button">Start Game</button>
      
      <!-- Game Over Overlay -->
      <div id="game-over-overlay" style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        color: white;
        font-family: Arial, sans-serif;
        z-index: 1000;
      ">
        <h1 style="color: #ff4444; font-size: 48px; margin: 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
          GAME OVER
        </h1>
        <p style="font-size: 24px; margin: 20px 0; text-align: center;">
          The foxes have overrun your chicken coop!<br>
          Wave reached: <span id="final-wave">0</span><br>
          Foxes defeated: <span id="final-score">0</span>
        </p>
        <button id="try-again-button" style="
          background: #4CAF50;
          color: white;
          border: none;
          padding: 15px 30px;
          font-size: 20px;
          border-radius: 8px;
          cursor: pointer;
          margin-top: 20px;
          box-shadow: 0 4px 8px rgba(0,0,0,0.3);
          transition: background-color 0.3s;
        " onmouseover="this.style.backgroundColor='#45a049'" onmouseout="this.style.backgroundColor='#4CAF50'">
          Try Again
        </button>
      </div>
    </div>
    <div id="tower-defense-controls" style="margin-top: 10px;">
      <button class="tower-button" data-type="scaredy" data-cost="25">Buy Scaredy-Cat (Cost: 25)</button>
      <button class="tower-button" data-type="normal" data-cost="50">Buy Chicken Tower (Cost: 50)</button>
      <button class="tower-button" data-type="super" data-cost="100">Buy Super Chicken (Cost: 100)</button>
      <button class="tower-button" data-type="slowing" data-cost="60">Buy Slowing Tower (Cost: 60)</button>
      <button class="tower-button" data-type="rapid" data-cost="80">Buy Rapid-Fire Tower (Cost: 80)</button>
      <button id="next-wave-button" style="display: none;">Start Next Wave</button>
      <button id="sell-tower-button">Sell Tower</button>
      <button id="target-button">Set Target</button>
      <button id="debug-sprites-button" onclick="toggleSpriteDebug()">Debug Sprites</button>
      <button id="debug-game-button" onclick="debugGame()">Debug Game</button>
    </div>
    <div class="game-instructions">
      <p><strong>How to play:</strong> Place towers to defend against incoming foxes. Earn money by defeating enemies.</p>
    </div>
  </div>
  
  <!-- Pac-Man Game -->
  <div id="pacman-container" class="game-container">
    <h2>Chicken vs. Foxes Maze</h2>
    <div class="game-stats" id="pacman-stats">
      <span>Score: <span id="pacman-score">0</span></span> |
      <span>Lives: <span id="pacman-lives">3</span></span> |
      <span>Level: <span id="pacman-level">1</span></span> |
      <span>Time: <span id="pacman-timer" style="color: #ff4500; font-weight: bold;">2:00</span></span>
      <div id="power-up-indicators" style="margin-top: 5px;">
        <span id="speed-indicator" style="display: none; margin-right: 10px;">‚ö° Speed</span>
        <span id="shield-indicator" style="display: none; margin-right: 10px;">üõ°Ô∏è Shield</span>
        <span id="freeze-indicator" style="display: none;">‚ùÑÔ∏è Freeze</span>
      </div>
    </div>
    <button id="pro-tip-button" style="margin: 10px 0; padding: 8px 16px; background-color: #ff6b35; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 14px;">üí° Get Pro Tip (Cost: 1 Life)</button>
    <div id="pro-tip-display" style="margin-bottom: 10px; font-size: 0.9em; color: #2a5a2a; background-color: rgba(144,238,144,0.3); padding: 10px; border-radius: 5px; border-left: 4px solid #2a5a2a; display: none;"></div>
    <div class="canvas-container">
      <canvas id="pacman-canvas" width="800" height="600"></canvas>
      <button class="start-button" id="pacman-start-button">Start Game</button>
      
      <!-- Character Selection Screen -->
      <div id="character-selection" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 255, 255, 0.98); padding: 40px; border-radius: 15px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); text-align: center; z-index: 1000; max-width: 600px;">
        <h2 style="margin: 0 0 20px 0; color: #333; font-size: 32px;">Choose Your Character</h2>
        <div style="display: flex; gap: 30px; justify-content: center; margin-top: 30px;">
          <!-- Chicken Option -->
          <div id="select-chicken" style="cursor: pointer; padding: 25px; border: 3px solid #4CAF50; border-radius: 12px; background: linear-gradient(135deg, #fffacd 0%, #fff8dc 100%); transition: all 0.3s; width: 220px;">
            <div style="font-size: 80px; margin-bottom: 15px;">üêî</div>
            <h3 style="margin: 10px 0; color: #2d5016; font-size: 24px;">Chicken</h3>
            <p style="color: #555; font-size: 14px; line-height: 1.6; margin: 10px 0;">
              <strong>Objective:</strong> Collect all pellets and avoid foxes!<br>
              <strong>Special:</strong> Can use power-ups and gain lives
            </p>
          </div>
          
          <!-- Fox Option -->
          <div id="select-fox" style="cursor: pointer; padding: 25px; border: 3px solid #ff6b35; border-radius: 12px; background: linear-gradient(135deg, #ffe4d6 0%, #ffd5ba 100%); transition: all 0.3s; width: 220px;">
            <div style="font-size: 80px; margin-bottom: 15px;">ü¶ä</div>
            <h3 style="margin: 10px 0; color: #8b2500; font-size: 24px;">Fox</h3>
            <p style="color: #555; font-size: 14px; line-height: 1.6; margin: 10px 0;">
              <strong>Objective:</strong> Hunt the chicken AI!<br>
              <strong>Special:</strong> Can collect fox power-ups for boosts
            </p>
          </div>
        </div>
        <p style="margin-top: 25px; color: #666; font-size: 13px; font-style: italic;">Click on a character to select</p>
      </div>
      
      <!-- Virtual Controls for Mobile Devices -->
      <div class="virtual-controls" id="virtual-controls">
        <div class="arrow-key arrow-up" id="arrow-up">&#9650;</div>
        <div class="arrow-key arrow-left" id="arrow-left">&#9664;</div>
        <div class="arrow-key arrow-right" id="arrow-right">&#9654;</div>
        <div class="arrow-key arrow-down" id="arrow-down">&#9660;</div>
      </div>
    </div>
    <div class="game-instructions">
      <p><strong>How to play:</strong> Use arrow keys (or on-screen controls on mobile) to navigate the maze, collect chicken feed and avoid foxes!</p>
      <div id="power-up-tips" style="margin-top: 10px; font-size: 0.9em; color: #4a4a4a; background-color: rgba(255,255,0,0.1); padding: 8px; border-radius: 5px;"></div>
    </div>
  </div>

  <div id="minimap-wrapper" style="position: fixed; right: 20px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 10px; cursor: move; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); user-select: none;">
    <h3 style="margin: 0; color: #333; cursor: grab;">Minimap</h3>
    <canvas id="pacman-minimap-canvas" width="160" height="160" style="border: 2px solid #ccc; background-color: #222; display: block;"></canvas>
  </div>

  <script>
    // Game Selector Logic
    const towerDefenseButton = document.getElementById('tower-defense-button');
    const pacmanButton = document.getElementById('pacman-button');
    const towerDefenseContainer = document.getElementById('tower-defense-container');
    const pacmanContainer = document.getElementById('pacman-container');
    
    towerDefenseButton.addEventListener('click', () => {
      // Update button styling
      towerDefenseButton.classList.add('active');
      pacmanButton.classList.remove('active');
      
      // Show Tower Defense game, hide Pac-Man game
      towerDefenseContainer.classList.add('active');
      pacmanContainer.classList.remove('active');
    });
    
    pacmanButton.addEventListener('click', () => {
      // Update button styling
      pacmanButton.classList.add('active');
      towerDefenseButton.classList.remove('active');
      
      // Show Pac-Man game, hide Tower Defense game
      pacmanContainer.classList.add('active');
      towerDefenseContainer.classList.remove('active');
    });
    
    // Tower Defense Game Logic
    const canvas = document.getElementById('tower-defense-canvas');
    const ctx = canvas.getContext('2d');
    const startButton = document.getElementById('tower-defense-start-button');
    const moneySpan = document.getElementById('money');
    const livesSpan = document.getElementById('lives');
    const scoreSpan = document.getElementById('score');
    const waveSpan = document.getElementById('wave');
    const nextWaveButton = document.getElementById('next-wave-button');
    const sellTowerButton = document.getElementById('sell-tower-button');
    const targetButton = document.getElementById('target-button');
    const towerInfoBar = document.getElementById('tower-info-bar');

    let money = 150;
    let score = 0; // Track foxes defeated
    let lives = 10;
    let wave = 0;
    let enemies = [];
    let towers = [];
    let projectiles = [];
    let gameRunning = false;
    let waveInProgress = false;
    let towerToPlace = null;
    let sellingTower = false;
    let targetingMode = false;
    let globalTarget = null;
    let hoveredTower = null;

    // Super Chicken sprite animation variables
    let superChickenSprite = null;
    let superChickenSpriteLoaded = false;
    let superChickenStaticSprite = null; // Static version for idle state
    let superChickenIsAnimatedGif = true; // Using your animated GIF
    let superChickenGifCanvas = null; // Canvas to force GIF animation
    let superChickenGifCtx = null;
    const superChickenFrameWidth = 64;
    const superChickenFrameHeight = 64;

    // Enemy GIF animation variables
    let enemyGifs = {
        normal: { gif: null, loaded: false },
        speedy: { gif: null, loaded: false },
        tank: { gif: null, loaded: false }
    };
    const enemySpriteSize = 30;

    // Load the super chicken sprite
    function loadSuperChickenSprite() {
        // Load the animated GIF
        superChickenSprite = new Image();
        superChickenSprite.onload = () => {
            superChickenSpriteLoaded = true;
            console.log('Super chicken animated GIF loaded successfully');
            console.log('GIF dimensions:', superChickenSprite.width, 'x', superChickenSprite.height);
        };
        superChickenSprite.onerror = (error) => {
            console.error('Failed to load super chicken GIF:', error);
            console.log('Trying fallback canvas sprite');
            superChickenIsAnimatedGif = false;
            createFallbackSprite();
        };
        superChickenSprite.src = "images/chicken_cannon_animated.gif";
        
        // Load a static version for idle state
        superChickenStaticSprite = new Image();
        superChickenStaticSprite.onload = () => {
            console.log('Super chicken static image loaded successfully');
        };
        superChickenStaticSprite.onerror = () => {
            console.log('Static sprite failed, will use first frame of GIF');
        };
        // Try to load a static version, fallback to existing PNG
        superChickenStaticSprite.src = "images/image-1760203619908.png";
    }

    // Create a fallback sprite using canvas if the image file doesn't exist
    function createFallbackSprite() {
        const canvas = document.createElement('canvas');
        const totalFrames = 3; // Define locally since we removed the global
        canvas.width = superChickenFrameWidth * totalFrames; // 192px total
        canvas.height = superChickenFrameHeight; // 64px
        const ctx = canvas.getContext('2d');
        
        // Helper function to draw a chicken cannon
        function drawChickenCannon(offsetX, muzzleFlash = false, smoke = false, recoil = 0) {
            const x = offsetX;
            
            // Cannon base (round)
            ctx.fillStyle = '#4A4A4A'; // Dark gray metal
            ctx.beginPath();
            ctx.arc(x + 25, 32, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Cannon barrel
            ctx.fillStyle = '#666666'; // Gray metal
            ctx.fillRect(x + 15 - recoil, 28, 35, 8);
            
            // Cannon barrel tip
            ctx.fillStyle = '#333333'; // Darker tip
            ctx.fillRect(x + 48 - recoil, 27, 4, 10);
            
            // Chicken body (plump and round)
            ctx.fillStyle = '#FFFFFF'; // White chicken
            ctx.beginPath();
            ctx.ellipse(x + 20, 35, 12, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Chicken head
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(x + 15, 30, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Chicken beak
            ctx.fillStyle = '#FFA500'; // Orange beak
            ctx.beginPath();
            ctx.moveTo(x + 9, 30);
            ctx.lineTo(x + 5, 29);
            ctx.lineTo(x + 9, 32);
            ctx.fill();
            
            // Chicken eye
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x + 12, 28, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Chicken comb (red crown)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(x + 12, 24);
            ctx.lineTo(x + 14, 22);
            ctx.lineTo(x + 16, 24);
            ctx.lineTo(x + 18, 22);
            ctx.lineTo(x + 20, 24);
            ctx.lineTo(x + 18, 26);
            ctx.lineTo(x + 12, 26);
            ctx.fill();
            
            // Chicken wattle (red chin thing)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.ellipse(x + 14, 34, 2, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Chicken feet
            ctx.fillStyle = '#FFA500'; // Orange feet
            ctx.fillRect(x + 16, 43, 2, 4);
            ctx.fillRect(x + 20, 43, 2, 4);
            ctx.fillRect(x + 24, 43, 2, 4);
            
            // Muzzle flash
            if (muzzleFlash) {
                const gradient = ctx.createRadialGradient(x + 52, 32, 0, x + 52, 32, 12);
                gradient.addColorStop(0, '#FFFFFF');
                gradient.addColorStop(0.3, '#FFFF00');
                gradient.addColorStop(0.7, '#FF6600');
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x + 52, 32, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Add some spark effects
                ctx.fillStyle = '#FFFFFF';
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 * i) / 6;
                    const sparkX = x + 52 + Math.cos(angle) * 8;
                    const sparkY = 32 + Math.sin(angle) * 8;
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Smoke
            if (smoke) {
                // Multiple smoke puffs
                for (let i = 0; i < 3; i++) {
                    const smokeX = x + 48 + (i * 5);
                    const smokeY = 20 + (i * 3);
                    const smokeSize = 6 - i;
                    
                    ctx.fillStyle = `rgba(128, 128, 128, ${0.6 - i * 0.2})`;
                    ctx.beginPath();
                    ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Clear canvas with transparent background
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Frame 0: Idle state
        drawChickenCannon(0);
        
        // Frame 1: Firing state with muzzle flash
        drawChickenCannon(superChickenFrameWidth, true, false);
        
        // Frame 2: Smoke/recoil state
        drawChickenCannon(superChickenFrameWidth * 2, false, true, 3);
        
        // Convert canvas to image
        superChickenSprite = new Image();
        superChickenSprite.onload = () => {
            superChickenSpriteLoaded = true;
            console.log('Awesome super chicken cannon sprite created successfully');
        };
        superChickenSprite.src = canvas.toDataURL();
    }

    // Initialize sprite loading
    loadSuperChickenSprite();
    loadEnemyGifs();

    // Load enemy animated GIFs - use your animation.gif file
    function loadEnemyGifs() {
        // Use animation.gif for all enemy types
        loadEnemyGif('normal', 'animation.gif', 'Fox');
        loadEnemyGif('speedy', 'animation.gif', 'Wolf');  
        loadEnemyGif('tank', 'animation.gif', 'Boar');
    }

    // Load a specific enemy GIF file
    function loadEnemyGif(type, filename, name) {
        enemyGifs[type].gif = new Image();
        enemyGifs[type].gif.onload = () => {
            enemyGifs[type].loaded = true;
            console.log(`${name} GIF (${filename}) loaded successfully`);
        };
        enemyGifs[type].gif.onerror = () => {
            console.log(`${name} GIF (${filename}) failed to load, using emoji fallback`);
            enemyGifs[type].loaded = false;
        };
        enemyGifs[type].gif.src = `images/${filename}`;
    }



    const towerData = {
        scaredy: { name: 'Scaredy-Cat', cost: 25, damage: 3, range: 80, fireRate: 90, emoji: 'üê£', description: 'A cheap, weak tower. Better than nothing.' },
        normal: { name: 'Chicken Tower', cost: 50, damage: 5, range: 150, fireRate: 45, emoji: 'üêî', description: 'A standard, reliable tower.' },
        super: { name: 'Super Chicken', cost: 100, damage: 10, range: 200, fireRate: 30, emoji: 'üêì', description: 'An expensive but powerful tower with animated sprite cannon.' },
        slowing: { name: 'Ice Chicken', cost: 60, damage: 1, range: 180, fireRate: 60, emoji: 'üßä', description: 'Dramatically slows enemies within its extended range.' },
        rapid: { name: 'Gatling Chicken', cost: 80, damage: 4, range: 170, fireRate: 8, emoji: 'üí•', description: 'Unleashes a storm of projectiles with incredible firing speed.' }
    };

    const path = [
        { x: 0, y: 300 }, { x: 100, y: 300 }, { x: 100, y: 100 }, { x: 300, y: 100 },
        { x: 300, y: 500 }, { x: 500, y: 500 }, { x: 500, y: 200 }, { x: 700, y: 200 },
        { x: 700, y: 300 }, { x: 800, y: 300 }
    ];

    // Pre-generated static elements for the medieval path
    let pathStones = [];
    let pathGrass = [];
    let pathPebbles = [];
    let pathGenerated = false;

    function generateStaticPathElements() {
        if (pathGenerated) return;
        
        pathStones = [];
        pathGrass = [];
        pathPebbles = [];
        
        // Generate static cobblestones
        for (let i = 0; i < path.length - 1; i++) {
            const start = path[i];
            const end = path[i + 1];
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const steps = Math.floor(distance / 15);
            
            for (let j = 0; j <= steps; j++) {
                const t = j / steps;
                const x = start.x + dx * t;
                const y = start.y + dy * t;
                
                const perpX = -dy / distance;
                const perpY = dx / distance;
                
                for (let row = -1; row <= 1; row++) {
                    for (let col = -12; col <= 12; col += 6) {
                        const stoneX = x + perpX * col + (Math.random() - 0.5) * 4;
                        const stoneY = y + perpY * col + (Math.random() - 0.5) * 4;
                        const stoneSize = 4 + Math.random() * 3;
                        const weathering = Math.random();
                        
                        let stoneColor;
                        if (weathering < 0.3) {
                            stoneColor = '#8B7355';
                        } else if (weathering < 0.6) {
                            stoneColor = '#A0855B';
                        } else {
                            stoneColor = '#D2B48C';
                        }
                        
                        const hasMoss = Math.random() < 0.2;
                        const isPolygonal = Math.random() < 0.7;
                        const mossOffsetX = (Math.random() - 0.5) * 2;
                        const mossOffsetY = (Math.random() - 0.5) * 2;
                        const mossSize = 1 + Math.random();
                        const sides = isPolygonal ? 5 + Math.floor(Math.random() * 3) : 0;
                        
                        // Generate static radius values for polygonal stones
                        const radiusVariations = [];
                        if (isPolygonal) {
                            for (let s = 0; s < sides; s++) {
                                radiusVariations.push(0.7 + Math.random() * 0.6);
                            }
                        }
                        
                        pathStones.push({
                            x: stoneX,
                            y: stoneY,
                            size: stoneSize,
                            color: stoneColor,
                            hasMoss: hasMoss,
                            mossOffsetX: mossOffsetX,
                            mossOffsetY: mossOffsetY,
                            mossSize: mossSize,
                            isPolygonal: isPolygonal,
                            sides: sides,
                            radiusVariations: radiusVariations
                        });
                    }
                }
            }
        }
        
        // Generate static grass
        for (let i = 0; i < path.length - 1; i++) {
            const start = path[i];
            const end = path[i + 1];
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const perpX = -dy / distance;
            const perpY = dx / distance;
            
            for (let side = -1; side <= 1; side += 2) {
                for (let grass = 0; grass < distance; grass += 20) {
                    const t = grass / distance;
                    const roadX = start.x + dx * t;
                    const roadY = start.y + dy * t;
                    const grassX = roadX + perpX * side * (28 + Math.random() * 15);
                    const grassY = roadY + perpY * side * (28 + Math.random() * 15);
                    
                    if (Math.random() < 0.4) {
                        for (let blade = 0; blade < 3; blade++) {
                            const bladeX = grassX + (Math.random() - 0.5) * 6;
                            const bladeY = grassY + (Math.random() - 0.5) * 6;
                            const bladeEndX = bladeX + (Math.random() - 0.5) * 4;
                            const bladeEndY = bladeY - 3 - Math.random() * 4;
                            
                            pathGrass.push({
                                startX: bladeX,
                                startY: bladeY,
                                endX: bladeEndX,
                                endY: bladeEndY
                            });
                        }
                    }
                }
            }
        }
        
        // Generate static pebbles
        for (let i = 0; i < 30; i++) {
            const segmentIndex = Math.floor(Math.random() * (path.length - 1));
            const t = Math.random();
            const start = path[segmentIndex];
            const end = path[segmentIndex + 1];
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            
            const pebbleX = start.x + dx * t + (Math.random() - 0.5) * 30;
            const pebbleY = start.y + dy * t + (Math.random() - 0.5) * 30;
            const pebbleSize = 1 + Math.random() * 2;
            const pebbleColor = Math.random() < 0.5 ? '#696969' : '#A9A9A9';
            
            pathPebbles.push({
                x: pebbleX,
                y: pebbleY,
                size: pebbleSize,
                color: pebbleColor
            });
        }
        
        pathGenerated = true;
    }

    // Helper function to draw path with organic curves
    function drawPathWithCurves() {
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        
        // Create smooth, organic curves between path points
        for (let i = 1; i < path.length; i++) {
            if (i === path.length - 1) {
                ctx.lineTo(path[i].x, path[i].y);
            } else {
                const current = path[i];
                const next = path[i + 1];
                const prev = path[i - 1];
                
                // Calculate control points for smoother curves
                const controlOffset = 0.3;
                const cp1x = current.x + (prev.x - next.x) * controlOffset;
                const cp1y = current.y + (prev.y - next.y) * controlOffset;
                const cp2x = current.x - (prev.x - next.x) * controlOffset;
                const cp2y = current.y - (prev.y - next.y) * controlOffset;
                
                const midX = (current.x + next.x) / 2;
                const midY = (current.y + next.y) / 2;
                
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, midX, midY);
            }
        }
        ctx.stroke();
    }

    function drawPath() {
        // Generate static elements once
        generateStaticPathElements();
        
        // Create a masterpiece medieval road inspired by N.C. Wyeth's King Arthur illustrations
        
        // Foundation layer - deep earth and ancient foundations
        const foundationGradient = ctx.createLinearGradient(0, 0, 800, 600);
        foundationGradient.addColorStop(0, '#3D2914'); // Deep brown
        foundationGradient.addColorStop(0.5, '#4A341A'); // Rich earth
        foundationGradient.addColorStop(1, '#2F1B0C'); // Dark loam
        ctx.strokeStyle = foundationGradient;
        ctx.lineWidth = 70;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        drawPathWithCurves();
        
        // Ancient Roman substructure - weathered stone base
        ctx.strokeStyle = '#6B5B47'; // Ancient stone
        ctx.lineWidth = 65;
        drawPathWithCurves();
        
        // Medieval road base - centuries of wear
        const roadGradient = ctx.createLinearGradient(0, 200, 0, 400);
        roadGradient.addColorStop(0, '#8B7355'); // Weathered brown
        roadGradient.addColorStop(0.3, '#A0855B'); // Medium stone
        roadGradient.addColorStop(0.7, '#8B7355'); // Aged surface
        roadGradient.addColorStop(1, '#6B5B47'); // Deep shadows
        ctx.strokeStyle = roadGradient;
        ctx.lineWidth = 58;
        drawPathWithCurves();
        
        // Primary cobblestone surface with realistic variations
        const cobbleGradient = ctx.createRadialGradient(400, 300, 0, 400, 300, 400);
        cobbleGradient.addColorStop(0, '#D2B48C'); // Light tan center
        cobbleGradient.addColorStop(0.4, '#C19A6B'); // Medium tan
        cobbleGradient.addColorStop(0.8, '#A0855B'); // Darker edges
        cobbleGradient.addColorStop(1, '#8B7355'); // Shadow perimeter
        ctx.strokeStyle = cobbleGradient;
        ctx.lineWidth = 48;
        drawPathWithCurves();
        
        // Worn traffic patterns - heavy use areas
        ctx.strokeStyle = '#9B7A57'; // Worn stone
        ctx.lineWidth = 35;
        drawPathWithCurves();
        
        // Central cart track - deep grooves from centuries of wheels
        const trackGradient = ctx.createLinearGradient(0, 0, 0, 600);
        trackGradient.addColorStop(0, '#7A6142'); // Deep rut
        trackGradient.addColorStop(0.5, '#8B6914'); // Muddy center
        trackGradient.addColorStop(1, '#6B4E23'); // Shadow depth
        ctx.strokeStyle = trackGradient;
        ctx.lineWidth = 25;
        drawPathWithCurves();
        
        // Master-crafted individual cobblestones with artistic detail
        pathStones.forEach(stone => {
            // Create individual stone lighting based on position
            const lightAngle = Math.atan2(stone.y - 200, stone.x - 400) + Math.PI / 4;
            const lightIntensity = (Math.sin(lightAngle) + 1) / 2;
            
            // Base stone color with lighting
            const baseColor = stone.color;
            const r = parseInt(baseColor.substr(1, 2), 16);
            const g = parseInt(baseColor.substr(3, 2), 16);
            const b = parseInt(baseColor.substr(5, 2), 16);
            
            // Apply lighting
            const litR = Math.min(255, Math.floor(r * (0.7 + lightIntensity * 0.5)));
            const litG = Math.min(255, Math.floor(g * (0.7 + lightIntensity * 0.5)));
            const litB = Math.min(255, Math.floor(b * (0.7 + lightIntensity * 0.5)));
            
            // Shadow color
            const shadowR = Math.floor(r * 0.4);
            const shadowG = Math.floor(g * 0.4);
            const shadowB = Math.floor(b * 0.4);
            
            // Draw stone shadow first
            ctx.fillStyle = `rgb(${shadowR}, ${shadowG}, ${shadowB})`;
            ctx.beginPath();
            if (stone.isPolygonal) {
                for (let s = 0; s < stone.sides; s++) {
                    const angle = (s / stone.sides) * Math.PI * 2;
                    const radius = stone.size * stone.radiusVariations[s];
                    const sx = stone.x + Math.cos(angle) * radius + 1;
                    const sy = stone.y + Math.sin(angle) * radius + 1;
                    if (s === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.closePath();
            } else {
                ctx.arc(stone.x + 1, stone.y + 1, stone.size, 0, Math.PI * 2);
            }
            ctx.fill();
            
            // Draw main stone
            ctx.fillStyle = `rgb(${litR}, ${litG}, ${litB})`;
            ctx.strokeStyle = '#4A3429'; // Deep mortar color
            ctx.lineWidth = 0.8;
            
            ctx.beginPath();
            if (stone.isPolygonal) {
                for (let s = 0; s < stone.sides; s++) {
                    const angle = (s / stone.sides) * Math.PI * 2;
                    const radius = stone.size * stone.radiusVariations[s];
                    const sx = stone.x + Math.cos(angle) * radius;
                    const sy = stone.y + Math.sin(angle) * radius;
                    if (s === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.closePath();
            } else {
                ctx.arc(stone.x, stone.y, stone.size, 0, Math.PI * 2);
            }
            ctx.fill();
            ctx.stroke();
            
            // Add stone highlights
            const highlightR = Math.min(255, litR + 40);
            const highlightG = Math.min(255, litG + 40);
            const highlightB = Math.min(255, litB + 40);
            ctx.fillStyle = `rgb(${highlightR}, ${highlightG}, ${highlightB})`;
            ctx.beginPath();
            ctx.arc(stone.x - stone.size * 0.3, stone.y - stone.size * 0.3, stone.size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Enhanced moss with multiple shades
            if (stone.hasMoss) {
                // Dark moss base
                ctx.fillStyle = '#3D5F1F';
                ctx.beginPath();
                ctx.arc(stone.x + stone.mossOffsetX, 
                       stone.y + stone.mossOffsetY, 
                       stone.mossSize * 1.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Bright moss highlights
                ctx.fillStyle = '#556B2F';
                ctx.beginPath();
                ctx.arc(stone.x + stone.mossOffsetX * 0.7, 
                       stone.y + stone.mossOffsetY * 0.7, 
                       stone.mossSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Moss highlights
                ctx.fillStyle = '#6B8E23';
                ctx.beginPath();
                ctx.arc(stone.x + stone.mossOffsetX * 0.5, 
                       stone.y + stone.mossOffsetY * 0.5, 
                       stone.mossSize * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        
        // Clean stone wheel ruts - worn grooves without mud
        const rutGradient = ctx.createLinearGradient(0, 0, 0, 600);
        rutGradient.addColorStop(0, '#8B7355'); // Stone shadow
        rutGradient.addColorStop(0.3, '#A0855B'); // Medium stone
        rutGradient.addColorStop(0.7, '#9B7A57'); // Worn stone
        rutGradient.addColorStop(1, '#6B5B47'); // Deep shadow
        
        // Left wheel rut with artistic variation
        ctx.strokeStyle = rutGradient;
        ctx.lineWidth = 4;
        ctx.setLineDash([]);
        for (let pass = 0; pass < 3; pass++) {
            ctx.beginPath();
            for (let i = 0; i < path.length - 1; i++) {
                const start = path[i];
                const end = path[i + 1];
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const perpX = -dy / distance * (10 + pass * 2);
                const perpY = dx / distance * (10 + pass * 2);
                
                if (i === 0) ctx.moveTo(start.x + perpX, start.y + perpY);
                
                // Add organic variation to rut depth
                const variation = Math.sin(i * 0.8) * 2;
                ctx.lineTo(end.x + perpX + variation, end.y + perpY + variation);
            }
            ctx.lineWidth = 4 - pass;
            ctx.stroke();
        }
        
        // Right wheel rut with matching detail
        for (let pass = 0; pass < 3; pass++) {
            ctx.beginPath();
            for (let i = 0; i < path.length - 1; i++) {
                const start = path[i];
                const end = path[i + 1];
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const perpX = -dy / distance * (10 + pass * 2);
                const perpY = dx / distance * (10 + pass * 2);
                
                if (i === 0) ctx.moveTo(start.x - perpX, start.y - perpY);
                
                const variation = Math.sin(i * 0.8 + Math.PI) * 2;
                ctx.lineTo(end.x - perpX + variation, end.y - perpY + variation);
            }
            ctx.lineWidth = 4 - pass;
            ctx.stroke();
        }
        
        // Artistic wild vegetation with medieval atmosphere
        ctx.strokeStyle = '#2F4F2F'; // Dark forest green base
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        pathGrass.forEach((blade, index) => {
            // Vary grass color for depth
            if (index % 3 === 0) ctx.strokeStyle = '#228B22';
            else if (index % 3 === 1) ctx.strokeStyle = '#32CD32';
            else ctx.strokeStyle = '#2F4F2F';
            
            ctx.beginPath();
            ctx.moveTo(blade.startX, blade.startY);
            ctx.lineTo(blade.endX, blade.endY);
            ctx.stroke();
        });
        
        // Add atmospheric wildflowers and herbs
        for (let i = 0; i < 15; i++) {
            const segmentIndex = Math.floor(Math.random() * (path.length - 1));
            const t = Math.random();
            const start = path[segmentIndex];
            const end = path[segmentIndex + 1];
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const perpX = -dy / distance;
            const perpY = dx / distance;
            
            const side = Math.random() < 0.5 ? -1 : 1;
            const flowerX = start.x + dx * t + perpX * side * (35 + Math.random() * 20);
            const flowerY = start.y + dy * t + perpY * side * (35 + Math.random() * 20);
            
            // Tiny wildflowers
            const colors = ['#9370DB', '#FFB6C1', '#FFFACD', '#98FB98'];
            ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
            ctx.beginPath();
            ctx.arc(flowerX, flowerY, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Artistic scattered debris and medieval atmosphere
        pathPebbles.forEach(pebble => {
            // Enhanced pebbles with better shading
            const shadowOffset = 1;
            
            // Pebble shadow
            ctx.fillStyle = '#3C3C3C';
            ctx.beginPath();
            ctx.arc(pebble.x + shadowOffset, pebble.y + shadowOffset, pebble.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Main pebble
            ctx.fillStyle = pebble.color;
            ctx.beginPath();
            ctx.arc(pebble.x, pebble.y, pebble.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Pebble highlight
            ctx.fillStyle = '#D3D3D3';
            ctx.beginPath();
            ctx.arc(pebble.x - pebble.size * 0.3, pebble.y - pebble.size * 0.3, pebble.size * 0.3, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // Add medieval road atmosphere - morning mist effect
        const mistGradient = ctx.createRadialGradient(400, 300, 0, 400, 300, 600);
        mistGradient.addColorStop(0, 'rgba(255, 255, 255, 0.02)');
        mistGradient.addColorStop(0.5, 'rgba(240, 240, 240, 0.05)');
        mistGradient.addColorStop(1, 'rgba(200, 200, 200, 0.08)');
        
        ctx.fillStyle = mistGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Final artistic touches - road wear patterns
        ctx.strokeStyle = 'rgba(160, 133, 91, 0.3)';
        ctx.lineWidth = 1;
        for (let i = 0; i < path.length - 1; i++) {
            const start = path[i];
            const end = path[i + 1];
            
            // Add subtle wear lines across the road
            for (let wear = 0; wear < 5; wear++) {
                const t = wear / 4;
                const wearX = start.x + (end.x - start.x) * t;
                const wearY = start.y + (end.y - start.y) * t;
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const perpX = -dy / distance * 15;
                const perpY = dx / distance * 15;
                
                ctx.beginPath();
                ctx.moveTo(wearX - perpX, wearY - perpY);
                ctx.lineTo(wearX + perpX, wearY + perpY);
                ctx.stroke();
            }
        }
        
        // Draw global target if it exists
        if (globalTarget) {
            drawCrosshair(globalTarget.x, globalTarget.y, 'rgba(255, 255, 0, 0.7)', true);
        }
    }
    
    // Helper function to draw a crosshair
    function drawCrosshair(x, y, color = 'red', isGlobal = false) {
        const size = isGlobal ? 20 : 15;
        const circleSize = isGlobal ? 15 : 12;
        const innerSize = isGlobal ? 7 : 5;
        
        // Target circle
        ctx.beginPath();
        ctx.arc(x, y, circleSize, 0, Math.PI * 2);
        ctx.fillStyle = isGlobal ? 'rgba(255, 255, 0, 0.2)' : 'rgba(255, 0, 0, 0.3)';
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = isGlobal ? 3 : 2;
        ctx.stroke();
        
        // Crosshair
        ctx.beginPath();
        ctx.moveTo(x - size, y);
        ctx.lineTo(x + size, y);
        ctx.moveTo(x, y - size);
        ctx.lineTo(x, y + size);
        ctx.strokeStyle = color;
        ctx.lineWidth = isGlobal ? 3 : 2;
        ctx.stroke();
        
        // Center dot
        ctx.beginPath();
        ctx.arc(x, y, innerSize, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.stroke();
    }
    
    function drawCoop() {
        // The coop is now just the emoji at the end of the path
        ctx.font = "40px Arial";
        ctx.fillText("üõñ", 750, 320);
    }

    function gameLoop() {
        if (!gameRunning) return;
        
        try {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPath();
            drawCoop();
            
            towers.forEach(t => {
                try {
                    t.update();
                } catch (error) {
                    console.error('Error updating tower:', error);
                }
            });
            
            enemies.forEach(e => {
                try {
                    e.update();
                } catch (error) {
                    console.error('Error updating enemy:', error);
                }
            });
            
            projectiles.forEach(p => {
                try {
                    p.update();
                } catch (error) {
                    console.error('Error updating projectile:', error);
                }
            });

            enemies = enemies.filter(e => {
                if (!e.isAlive) {
                    e.cleanup(); // Clean up GIF elements
                    return false;
                }
                return true;
            });
            projectiles = projectiles.filter(p => p.isAlive);

            if (waveInProgress && enemies.length === 0) {
                waveInProgress = false;
                nextWaveButton.style.display = 'inline-block';
            }
        } catch (error) {
            console.error('Error in game loop:', error);
        }

        requestAnimationFrame(gameLoop);
    }

    function showGameOver() {
        gameRunning = false;
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const finalWaveSpan = document.getElementById('final-wave');
        const finalScoreSpan = document.getElementById('final-score');
        
        finalWaveSpan.textContent = wave;
        finalScoreSpan.textContent = score;
        
        gameOverOverlay.style.display = 'flex';
    }

    function restartGame() {
        // Reset all game variables
        money = 150;
        lives = 10;
        wave = 0;
        score = 0;
        gameRunning = false;
        waveInProgress = false;
        enemies = [];
        projectiles = [];
        towers = [];
        
        // Clear all DOM elements created for towers and enemies
        const existingElements = document.querySelectorAll('.tower-gif-element, .tower-static-element, .enemy-gif-element');
        existingElements.forEach(element => element.remove());
        
        // Clean up any remaining enemy GIF elements
        enemies.forEach(enemy => enemy.cleanup());
        
        // Reset UI
        moneySpan.textContent = money;
        livesSpan.textContent = lives;
        waveSpan.textContent = wave;
        scoreSpan.textContent = score;
        
        // Hide game over overlay
        const gameOverOverlay = document.getElementById('game-over-overlay');
        gameOverOverlay.style.display = 'none';
        
        // Show start button
        startButton.style.display = 'inline-block';
        nextWaveButton.style.display = 'none';
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawPath();
    }

    startButton.addEventListener('click', () => {
        if (!gameRunning) {
            gameRunning = true;
            startButton.style.display = 'none';
            nextWaveButton.style.display = 'inline-block';
            gameLoop();
        }
    });

    nextWaveButton.addEventListener('click', () => {
        if (gameRunning && !waveInProgress) {
            startNextWave();
        }
    });

    // Try Again button event listener
    const tryAgainButton = document.getElementById('try-again-button');
    tryAgainButton.addEventListener('click', () => {
        restartGame();
    });

    function startNextWave() {
        waveInProgress = true;
        nextWaveButton.style.display = 'none';
        wave++;
        waveSpan.textContent = wave;
        
        const waveComposition = [];
        const numEnemies = wave * 5;
        for (let i = 0; i < numEnemies; i++) {
            const rand = Math.random();
            if (wave > 4 && rand < 0.2) {
                waveComposition.push('tank');
            } else if (wave > 2 && rand < 0.5) {
                waveComposition.push('speedy');
            } else {
                waveComposition.push('normal');
            }
        }

        waveComposition.forEach((enemyType, i) => {
            setTimeout(() => {
                if (gameRunning) enemies.push(new Enemy(enemyType));
            }, i * (1000 / (1 + wave * 0.1)));
        });
    }

    class Enemy {
        constructor(type = 'normal') {
            this.x = path[0].x;
            this.y = path[0].y;
            this.pathIndex = 0;
            this.type = type;
            this.isAlive = true;
            this.slowedUntil = 0;
            this.originalSpeed = 1;
            this.gifElement = null;
            this.id = 'enemy_' + Date.now() + '_' + Math.random(); // Unique ID for each enemy

            switch(type) {
                case 'speedy':
                    this.originalSpeed = 2.5 + wave * 0.1;
                    this.maxHealth = 30 + wave * 8;
                    this.emoji = 'üê∫';
                    break;
                case 'tank':
                    this.originalSpeed = 0.8 + wave * 0.05;
                    this.maxHealth = 200 + wave * 40;
                    this.emoji = 'üêó';
                    break;
                default: // normal
                    this.originalSpeed = 1.5 + wave * 0.1;
                    this.maxHealth = 50 + wave * 10;
                    this.emoji = 'ü¶ä';
                    break;
            }
            this.speed = this.originalSpeed;
            this.health = this.maxHealth;
            this.rotation = 0; // Initialize rotation for directional facing
            
            // Create GIF element if available
            this.createGifElement();
        }

        createGifElement() {
            const gifData = enemyGifs[this.type];
            if (gifData && gifData.loaded) {
                this.gifElement = document.createElement('img');
                this.gifElement.src = gifData.gif.src;
                this.gifElement.style.position = 'absolute';
                this.gifElement.style.width = enemySpriteSize + 'px';
                this.gifElement.style.height = enemySpriteSize + 'px';
                this.gifElement.style.pointerEvents = 'none';
                this.gifElement.style.zIndex = '5';
                this.gifElement.classList.add('enemy-gif-element');
                this.gifElement.id = this.id;
                
                // Add to canvas container
                const canvasContainer = canvas.parentElement;
                if (canvasContainer.style.position !== 'relative') {
                    canvasContainer.style.position = 'relative';
                }
                canvasContainer.appendChild(this.gifElement);
                
                console.log(`Created GIF element for ${this.type} enemy`);
            }
        }

        cleanup() {
            // Remove GIF element when enemy is destroyed
            if (this.gifElement) {
                this.gifElement.remove();
                this.gifElement = null;
            }
        }

        update() {
            if (Date.now() > this.slowedUntil) {
                this.speed = this.originalSpeed;
            }

            if (this.pathIndex >= path.length - 1) {
                this.isAlive = false;
                this.cleanup();
                lives--;
                livesSpan.textContent = lives;
                if (lives <= 0) {
                    showGameOver();
                }
                return;
            }

            const target = path[this.pathIndex + 1];
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Calculate rotation based on movement direction
            if (dx !== 0 || dy !== 0) {
                this.rotation = Math.atan2(dy, dx);
            }

            if (distance < this.speed) {
                this.pathIndex++;
            } else {
                this.x += (dx / distance) * this.speed;
                this.y += (dy / distance) * this.speed;
            }
            
            // Update GIF position if it exists
            this.updateGifPosition();
            this.draw();
        }

        updateGifPosition() {
            if (this.gifElement) {
                const canvasStyle = window.getComputedStyle(canvas);
                const canvasMarginLeft = parseInt(canvasStyle.marginLeft) || 0;
                const canvasMarginTop = parseInt(canvasStyle.marginTop) || 0;
                const canvasBorderLeft = parseInt(canvasStyle.borderLeftWidth) || 0;
                const canvasBorderTop = parseInt(canvasStyle.borderTopWidth) || 0;
                
                const leftPos = canvasMarginLeft + canvasBorderLeft + this.x - enemySpriteSize/2;
                const topPos = canvasMarginTop + canvasBorderTop + this.y - enemySpriteSize/2;
                
                this.gifElement.style.left = leftPos + 'px';
                this.gifElement.style.top = topPos + 'px';
                
                // Apply rotation based on movement direction
                if (this.rotation !== undefined) {
                    this.gifElement.style.transform = `rotate(${this.rotation}rad)`;
                    this.gifElement.style.transformOrigin = 'center center';
                }
            }
        }

        draw() {
            // Health bar
            const barWidth = 30;
            const barHeight = 5;
            const barX = this.x - barWidth / 2;
            const barY = this.y - 20;
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            const healthPercentage = this.health / this.maxHealth;
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(barX, barY, barWidth * healthPercentage, barHeight);

            // Draw GIF or emoji
            const gifData = enemyGifs[this.type];
            if (this.gifElement && gifData && gifData.loaded) {
                // GIF is handled by DOM element, just draw a subtle placeholder
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, enemySpriteSize/2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            } else {
                // Fallback to emoji if GIF not available
                ctx.save();
                ctx.translate(this.x, this.y);
                if (this.rotation !== undefined) {
                    ctx.rotate(this.rotation);
                }
                ctx.font = "25px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
                ctx.textAlign = "start";
                ctx.textBaseline = "alphabetic";
            }
        }
    }

    class Tower {
        constructor(x, y, type, cost) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.cost = cost;
            const data = towerData[type];
            this.range = data.range;
            this.fireRate = data.fireRate;
            this.damage = data.damage;
            this.emoji = data.emoji;
            this.fireCooldown = 0;
            this.targetPosition = null;
            this.isSelected = false;
            
            // Animation properties for super chicken
            if (type === 'super') {
                // Track firing state for animation control
                this.isFiring = false;
                this.fireAnimationTimer = 0;
                this.fireAnimationDuration = 1000; // 1 second of animation
                console.log('Super chicken tower created with firing animation control');
            }
        }

        update() {
            this.fireCooldown--;
            if (this.fireCooldown <= 0) {
                const target = this.findTarget();
                if (target) {
                    try {
                        projectiles.push(new Projectile(this.x, this.y, target, this.damage, this.type));
                        this.fireCooldown = this.fireRate;
                        
                        // Trigger firing animation for super chicken
                        if (this.type === 'super') {
                            this.isFiring = true;
                            this.fireAnimationTimer = Date.now();
                            console.log('Super chicken firing - starting animation');
                        }
                    } catch (error) {
                        console.error('Error creating projectile:', error);
                    }
                }
            }
            
            // Update firing animation state for super chicken
            if (this.type === 'super' && this.isFiring) {
                if (Date.now() - this.fireAnimationTimer > this.fireAnimationDuration) {
                    this.isFiring = false;
                    console.log('Super chicken firing animation ended');
                }
            }
            
            this.draw();
        }

        findTarget() {
            // Use individual target if set, or global target as fallback
            const targetPos = this.targetPosition || globalTarget;
            
            // If any target is set, prioritize enemies near that position
            if (targetPos) {
                // Find enemies within range of both the tower and the target position
                let bestTarget = null;
                let bestScore = Infinity;
                
                enemies.forEach(enemy => {
                    const dxTower = enemy.x - this.x;
                    const dyTower = enemy.y - this.y;
                    const distanceToTower = Math.sqrt(dxTower * dxTower + dyTower * dyTower);
                    
                    // Only consider enemies within the tower's range
                    if (distanceToTower <= this.range) {
                        const dxTarget = enemy.x - targetPos.x;
                        const dyTarget = enemy.y - targetPos.y;
                        const distanceToTarget = Math.sqrt(dxTarget * dxTarget + dyTarget * dyTarget);
                        
                        // Score is based on distance to target position
                        // Lower score is better (closer to target)
                        const score = distanceToTarget;
                        
                        if (score < bestScore) {
                            bestScore = score;
                            bestTarget = enemy;
                        }
                    }
                });
                
                if (bestTarget) return bestTarget;
            }
            
            // If no target position or no enemies near target, fall back to closest enemy
            let closestEnemy = null;
            let closestDistance = Infinity;
            
            enemies.forEach(enemy => {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < closestDistance && distance <= this.range) {
                    closestDistance = distance;
                    closestEnemy = enemy;
                }
            });
            
            return closestEnemy;
        }

        updateSuperChickenAnimation() {
            const now = Date.now();
            
            // Handle firing animation timing
            if (this.isFiring) {
                // Total firing sequence duration is frame 1 (200ms) + frame 2 (400ms) = 600ms
                const timeSinceFiring = now - this.fireAnimationTimer;
                
                if (timeSinceFiring <= superChickenFrameDurations[1]) {
                    // Still in firing frame (frame 1)
                    this.animationFrame = 1;
                } else if (timeSinceFiring <= superChickenFrameDurations[1] + superChickenFrameDurations[2]) {
                    // Now in smoke frame (frame 2)
                    this.animationFrame = 2;
                } else {
                    // Firing sequence complete, return to idle
                    this.isFiring = false;
                    this.animationFrame = 0;
                    this.animationTimer = now;
                }
            } else {
                // When not firing, stay on idle frame (0) and handle idle animation
                if (now - this.animationTimer > this.currentFrameDuration) {
                    this.animationFrame = 0;
                    this.animationTimer = now;
                    this.currentFrameDuration = superChickenFrameDurations[0];
                }
            }
        }

        draw() {
            // Special rendering for super chicken with animated GIF
            if (this.type === 'super' && superChickenSpriteLoaded && superChickenSprite) {
                ctx.save();
                
                const spriteSize = 60;
                try {
                    // Determine which image to show based on firing state
                    const shouldAnimate = this.isFiring;
                    
                    // Check if we already have a DOM element for this tower
                    if (!this.gifElement) {
                        // Create static image element
                        this.staticElement = document.createElement('img');
                        this.staticElement.style.position = 'absolute';
                        this.staticElement.style.width = spriteSize + 'px';
                        this.staticElement.style.height = spriteSize + 'px';
                        this.staticElement.style.pointerEvents = 'none';
                        this.staticElement.style.zIndex = '10';
                        this.staticElement.src = superChickenStaticSprite.src || "images/image-1760203619908.png";
                        
                        // Create animated GIF element
                        this.gifElement = document.createElement('img');
                        this.gifElement.src = "images/chicken_cannon_animated.gif";
                        this.gifElement.style.position = 'absolute';
                        this.gifElement.style.width = spriteSize + 'px';
                        this.gifElement.style.height = spriteSize + 'px';
                        this.gifElement.style.pointerEvents = 'none';
                        this.gifElement.style.zIndex = '10';
                        this.gifElement.style.display = 'none'; // Start hidden
                        
                        // Add both to the canvas container
                        const canvasContainer = canvas.parentElement;
                        if (canvasContainer.style.position !== 'relative') {
                            canvasContainer.style.position = 'relative';
                        }
                        canvasContainer.appendChild(this.staticElement);
                        canvasContainer.appendChild(this.gifElement);
                        
                        console.log('Created both static and animated elements for Super Chicken tower');
                    }
                    
                    // Position both elements
                    const canvasStyle = window.getComputedStyle(canvas);
                    const canvasMarginLeft = parseInt(canvasStyle.marginLeft) || 0;
                    const canvasMarginTop = parseInt(canvasStyle.marginTop) || 0;
                    const canvasBorderLeft = parseInt(canvasStyle.borderLeftWidth) || 0;
                    const canvasBorderTop = parseInt(canvasStyle.borderTopWidth) || 0;
                    
                    const leftPos = canvasMarginLeft + canvasBorderLeft + this.x - spriteSize/2;
                    const topPos = canvasMarginTop + canvasBorderTop + this.y - spriteSize/2;
                    
                    // Update positions for both elements
                    this.staticElement.style.left = leftPos + 'px';
                    this.staticElement.style.top = topPos + 'px';
                    this.gifElement.style.left = leftPos + 'px';
                    this.gifElement.style.top = topPos + 'px';
                    
                    // Show/hide based on firing state
                    if (shouldAnimate) {
                        this.staticElement.style.display = 'none';
                        this.gifElement.style.display = 'block';
                    } else {
                        this.staticElement.style.display = 'block';
                        this.gifElement.style.display = 'none';
                    }
                    
                    // Draw a placeholder circle on canvas to show tower is there
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, spriteSize/2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                } catch (error) {
                    console.error('Error setting up animated GIF element:', error);
                    // Fallback to emoji if GIF fails
                    ctx.font = "30px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = 'red';
                    ctx.fillText(this.emoji, this.x, this.y);
                }
                
                ctx.restore();
                
                // Debug info
                if (typeof window.DEBUG_SPRITES !== 'undefined' && window.DEBUG_SPRITES) {
                    ctx.save();
                    ctx.font = "10px Arial";
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    const debugText = this.isFiring ? 'FIRING' : 'IDLE';
                    ctx.strokeText(debugText, this.x - 15, this.y - 30);
                    ctx.fillText(debugText, this.x - 15, this.y - 30);
                    ctx.restore();
                }
            } else {
                // Fallback to emoji for other towers or if GIF fails
                ctx.save();
                ctx.font = "30px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = 'white';
                ctx.fillText(this.emoji, this.x, this.y);
                ctx.restore();
            }

            // Draw range circle when tower is selected or hovered
            if (this.isSelected || this === hoveredTower) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
            
            // Draw target if this tower has one
            if (this.targetPosition) {
                ctx.save();
                // Line from tower to target
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.targetPosition.x, this.targetPosition.y);
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw the crosshair
                drawCrosshair(this.targetPosition.x, this.targetPosition.y);
                ctx.restore();
            }
        }
    }

    class Projectile {
        constructor(x, y, target, damage, towerType) {
            this.x = x;
            this.y = y;
            this.target = target;
            this.damage = damage;
            this.towerType = towerType;
            this.speed = 5;
            this.isAlive = true;
        }

        update() {
            if (!this.target.isAlive) {
                this.isAlive = false;
                return;
            }

            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.speed) {
                // Direct hit
                this.target.health -= this.damage;
                
                // Apply slowing effect if projectile is from a slowing tower
                if (this.towerType === 'slowing') {
                    this.target.speed = this.target.originalSpeed * 0.3; // Slow to 30% speed (much stronger slow)
                    this.target.slowedUntil = Date.now() + 3500; // Slow for 3.5 seconds (longer duration)
                }
                
                if (this.target.health <= 0) {
                    this.target.isAlive = false;
                    this.target.cleanup(); // Clean up GIF elements
                    // Add 5 money for every fox destroyed
                    money += 5;
                    moneySpan.textContent = money;
                    // Increment score for every fox defeated
                    score++;
                    scoreSpan.textContent = score;
                }
                this.isAlive = false;
            } else {
                this.x += (dx / distance) * this.speed;
                this.y += (dy / distance) * this.speed;
            }

            this.draw();
        }

        draw() {
            // Different projectile colors based on tower type
            if (this.towerType === 'slowing') {
                ctx.fillStyle = '#00ccff'; // Ice blue for slowing projectiles
            } else if (this.towerType === 'rapid') {
                ctx.fillStyle = '#ff6600'; // Orange for rapid fire projectiles
            } else {
                ctx.fillStyle = '#ffcc00'; // Default yellow
            }
            
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    document.querySelectorAll('.tower-button').forEach(button => {
        const type = button.dataset.type;
        const data = towerData[type];

        button.addEventListener('mouseenter', () => {
            towerInfoBar.innerHTML = `
                <h3>${data.name}</h3>
                <p>Cost: ${data.cost} | Damage: ${data.damage} | Range: ${data.range} | Fire Rate: ${data.fireRate}</p>
                <p><em>${data.description}</em></p>
            `;
        });

        button.addEventListener('mouseleave', () => {
            towerInfoBar.innerHTML = '';
        });

        button.addEventListener('click', () => {
            if (money >= data.cost) {
                towerToPlace = { type, cost: data.cost };
                sellingTower = false;
                sellTowerButton.textContent = 'Sell Tower';
                canvas.style.cursor = 'crosshair';
            } else {
                alert("Not enough money!");
            }
        });
    });

    sellTowerButton.addEventListener('click', () => {
      sellingTower = !sellingTower;
      targetingMode = false;
      towerToPlace = null;
      
      if (sellingTower) {
          sellTowerButton.textContent = 'Cancel';
          targetButton.textContent = 'Set Target';
          towerInfoBar.innerHTML = '<h3>Sell Tower</h3><p>Select a tower to sell.</p>';
          canvas.style.cursor = 'crosshair';
      } else {
          sellTowerButton.textContent = 'Sell Tower';
          towerInfoBar.innerHTML = '';
          canvas.style.cursor = 'auto';
      }
    });
    
    targetButton.addEventListener('click', () => {
      // Toggle targeting mode
      targetingMode = !targetingMode;
      
      if (targetingMode) {
          // Enter targeting mode
          sellingTower = false;
          towerToPlace = null;
          
          targetButton.textContent = 'Cancel Targeting';
          sellTowerButton.textContent = 'Sell Tower';
          towerInfoBar.innerHTML = '<h3>Set Target</h3><p>Click anywhere on the map to set a global target for all towers.</p>';
          canvas.style.cursor = 'crosshair';
      } else {
          // Exit targeting mode
          targetButton.textContent = 'Set Target';
          towerInfoBar.innerHTML = '';
          canvas.style.cursor = 'auto';
      }
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      if (targetingMode) {
          // Set global target for all towers
          globalTarget = { x, y };
          
          // Exit targeting mode
          targetingMode = false;
          targetButton.textContent = 'Set Target';
          
          // Update UI
          towerInfoBar.innerHTML = '<h3>Global Target Set!</h3><p>All towers will focus fire on enemies near this location.</p>';
          setTimeout(() => {
            if (towerInfoBar.innerHTML.includes('Target Set!')) {
              towerInfoBar.innerHTML = '';
            }
          }, 3000);
          canvas.style.cursor = 'auto';
      }
      else if (sellingTower) {
          const towerIndex = towers.findIndex(t => {
              const dx = t.x - x;
              const dy = t.y - y;
              return Math.sqrt(dx * dx + dy * dy) < 30;
          });

          if (towerIndex !== -1) {
              const tower = towers[towerIndex];
              
              // Clean up both GIF elements if they exist
              if (tower.gifElement) {
                  tower.gifElement.remove();
              }
              if (tower.staticElement) {
                  tower.staticElement.remove();
              }
              
              money += Math.floor(tower.cost / 2);
              moneySpan.textContent = money;
              towers.splice(towerIndex, 1);
          }
          sellingTower = false;
          sellTowerButton.textContent = 'Sell Tower';
          canvas.style.cursor = 'auto';
      } else if (towerToPlace) {
        // Check if the click is within the canvas area and not on the path
        if (x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height) {
            if (!isOverPath(x, y)) {
                towers.push(new Tower(x, y, towerToPlace.type, towerToPlace.cost));
                money -= towerToPlace.cost;
                moneySpan.textContent = money;
                towerToPlace = null;
                canvas.style.cursor = 'auto'; // Reset cursor after placement
            } else {
                alert("You can't place a tower on the path!");
            }
        }
      }
    });


    function isOverPath(x, y) {
        const pathWidth = 40;
        for (let i = 0; i < path.length - 1; i++) {
            const p1 = path[i];
            const p2 = path[i+1];
            const minX = Math.min(p1.x, p2.x) - pathWidth / 2;
            const maxX = Math.max(p1.x, p2.x) + pathWidth / 2;
            const minY = Math.min(p1.y, p2.y) - pathWidth / 2;
            const maxY = Math.max(p1.y, p2.y) + pathWidth / 2;
            if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                if (p1.x === p2.x) {
                    if (Math.abs(x - p1.x) < pathWidth / 2) return true;
                } else if (p1.y === p2.y) {
                    if (Math.abs(y - p1.y) < pathWidth / 2) return true;
                }
            }
        }
        return false;
    }
    
    // Debug function to toggle sprite debug mode
    function toggleSpriteDebug() {
        window.DEBUG_SPRITES = !window.DEBUG_SPRITES;
        const button = document.getElementById('debug-sprites-button');
        button.textContent = window.DEBUG_SPRITES ? 'Debug ON' : 'Debug Sprites';
        button.style.backgroundColor = window.DEBUG_SPRITES ? '#ff6666' : '';
        console.log('Sprite debug mode:', window.DEBUG_SPRITES ? 'ON' : 'OFF');
        
        // Log current super chicken towers and their animation state
        const superTowers = towers.filter(t => t.type === 'super');
        if (superTowers.length > 0) {
            console.log('Super chicken towers found:', superTowers.length);
            superTowers.forEach((tower, index) => {
                console.log(`Tower ${index}:`, {
                    x: tower.x,
                    y: tower.y,
                    spriteLoaded: superChickenSpriteLoaded
                });
            });
        } else {
            console.log('No super chicken towers found');
        }
    }
    
    // Debug function to check game state
    function debugGame() {
        console.log('=== GAME DEBUG INFO ===');
        console.log('Game running:', gameRunning);
        console.log('Towers:', towers.length);
        console.log('Enemies:', enemies.length);
        console.log('Projectiles:', projectiles.length);
        console.log('Super chicken sprite loaded:', superChickenSpriteLoaded);
        console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
        
        // Log super chicken towers specifically
        const superTowers = towers.filter(t => t.type === 'super');
        console.log('Super chicken towers:', superTowers.length);
        superTowers.forEach((tower, i) => {
            console.log(`Super tower ${i}:`, {
                x: tower.x,
                y: tower.y,
                damage: tower.damage,
                range: tower.range,
                fireCooldown: tower.fireCooldown
            });
        });
        
        console.log('========================');
    }
    
    // ************* PAC-MAN GAME IMPLEMENTATION *************
    const pacmanCanvas = document.getElementById('pacman-canvas');
    const pacmanCtx = pacmanCanvas.getContext('2d');
    const pacmanMinimapCanvas = document.getElementById('pacman-minimap-canvas');
    const pacmanMinimapCtx = pacmanMinimapCanvas.getContext('2d');
    const pacmanStartButton = document.getElementById('pacman-start-button');
    const pacmanScoreSpan = document.getElementById('pacman-score');
    const pacmanLivesSpan = document.getElementById('pacman-lives');
    const pacmanTimerSpan = document.getElementById('pacman-timer');
    
    // Pac-Man chicken GIF variables
    let pacmanChickenGif = null;
    let pacmanChickenGifUrl = "images/running_chicken.gif";
    let pacmanChickenGifLoaded = false;
    let pacmanChickenElement = null;
    const pacmanChickenSize = 30;
    
    // Load the running chicken GIF for Pac-Man
    function loadPacmanChickenGif() {
        pacmanChickenGif = new Image();
        pacmanChickenGif.onload = () => {
            pacmanChickenGifLoaded = true;
            console.log('Pac-Man running chicken GIF loaded successfully');
        };
        pacmanChickenGif.onerror = (error) => {
            console.error('Failed to load Pac-Man chicken GIF:', error);
            pacmanChickenGifLoaded = false;
        };
        pacmanChickenGif.src = pacmanChickenGifUrl;
    }
    
    // Pac-Man fox GIF variables
    let pacmanFoxGifUrl = "images/animation.gif";
    let pacmanFoxGif = null;
    let pacmanFoxGifLoaded = false;
    const pacmanFoxSize = 30;
    
    // Load the animation GIF for foxes
    function loadPacmanFoxGif() {
        // Test if the GIF loads and create an image object for canvas drawing
        pacmanFoxGif = new Image();
        pacmanFoxGif.onload = () => {
            pacmanFoxGifLoaded = true;
            console.log('Pac-Man fox GIF loaded successfully');
        };
        pacmanFoxGif.onerror = (error) => {
            console.error('Failed to load Pac-Man fox GIF:', error);
            pacmanFoxGifLoaded = false;
        };
        pacmanFoxGif.src = pacmanFoxGifUrl;
    }
    
    // Pac-Man Game Variables
    let pacmanGameRunning = false;
    let pacmanScore = 0;
    let pacmanLives = 3;
    let nextLifeAt = 10000; // Score threshold for next extra life
    let pacmanPosition = { x: 400, y: 300 };
    let pacmanDirection = { x: 0, y: 0 };
    let pacmanMouthAngle = 0;
    let pacmanMouthDirection = 1;
    let ghosts = [];
    let pellets = [];
    let powerPellets = [];
    let lifePellets = []; // Special pellets that grant extra lives
    let specialPowerUps = []; // New special power-ups (speed, invincibility, freeze)
    let foxPowerUps = []; // Power-ups that foxes can collect
    let foxPowerUpSpawnTimer = 0;
    
    // Character selection
    let playerCharacter = 'chicken'; // 'chicken' or 'fox'
    let characterSelected = false;
    let spawnProtectionTime = 0; // Time until collision detection is enabled
    
    // Timer variables
    let gameTimeRemaining = 120; // 2 minutes in seconds
    let gameStartTime = 0;
    let lastTimerUpdate = 0;
    
    // Power-up states
    let speedBoostActive = false;
    let speedBoostTimer = 0;
    let invincibilityActive = false;
    let invincibilityTimer = 0;
    let freezeActive = false;
    let freezeTimer = 0;
    let maze = [];
    let currentLevel = 1;
    let nextLevelButton = null;
    let allGhostsEliminated = false;
    let pacmanSize = 15;
    let ghostSize = 15;
    
    // Ghost-passable walls map (tracks which walls can be passed through by ghost foxes)
    let ghostWalls = [];
    
    // Boss fox variables
    let bossActive = false;
    let bossFox = null;
    let bossHealth = 0;
    let bossMaxHealth = 0;
    let pelletSize = 5;
    let powerPelletSize = 10;
    let powerMode = false;
    let powerModeTimer = 0;
    let ghostsEaten = 0;
    let cellSize = 40; // Size of each maze cell
    
    // Create Maze Grid - 1 is wall, 0 is path
    function createMaze() {
        const mazeWidth = Math.floor(pacmanCanvas.width / cellSize);
        const mazeHeight = Math.floor(pacmanCanvas.height / cellSize);
        
        // Initialize empty maze
        maze = [];
        ghostWalls = []; // Initialize ghost-passable walls
        
        for (let y = 0; y < mazeHeight; y++) {
            const row = [];
            const ghostRow = [];
            for (let x = 0; x < mazeWidth; x++) {
                let isWall = false;
                let isGhostPassable = false;
                
                // Make walls around the edges
                if (x === 0 || y === 0 || x === mazeWidth - 1 || y === mazeHeight - 1) {
                    isWall = true;
                    isGhostPassable = false; // Edge walls are never passable
    
      
      
      
                } 
                // Create some internal walls in a pattern
                else if ((x % 2 === 0 && y % 2 === 0) && 
                         (x > 2 && y > 2) && 
                         (x < mazeWidth - 3 && y < mazeHeight - 3)) {
                    isWall = true;
                    // Internal grid walls are ghost-passable
                    isGhostPassable = true;
                } 
                // Create some horizontal walls
                else if ((y === 3 || y === mazeHeight - 4) && 
                        (x > 3 && x < mazeWidth - 4) && 
                        (x % 3 !== 0)) {
                    isWall = true;
                    // Most horizontal walls are ghost-passable (70% chance)
                    isGhostPassable = Math.random() < 0.7;
                }
                // Create some vertical walls
                else if ((x === 3 || x === mazeWidth - 4) && 
                        (y > 3 && y < mazeHeight - 4) && 
                        (y % 3 !== 0)) {
                    isWall = true;
                    // Most vertical walls are ghost-passable (70% chance)
                    isGhostPassable = Math.random() < 0.7;
                }
                
                row.push(isWall ? 1 : 0);
                ghostRow.push(isGhostPassable ? 1 : 0);
            }
            maze.push(row);
            ghostWalls.push(ghostRow);
        }
        
        // Ensure Pac-Man starting position is a path
        const startX = Math.floor(pacmanPosition.x / cellSize);
        const startY = Math.floor(pacmanPosition.y / cellSize);
        if (startX >= 0 && startX < mazeWidth && startY >= 0 && startY < mazeHeight) {
            maze[startY][startX] = 0;
            ghostWalls[startY][startX] = 0; // Can't pass through start
            // Clear a small area around starting position
            for (let y = Math.max(0, startY - 1); y <= Math.min(mazeHeight - 1, startY + 1); y++) {
                for (let x = Math.max(0, startX - 1); x <= Math.min(mazeWidth - 1, startX + 1); x++) {
                    maze[y][x] = 0;
                    ghostWalls[y][x] = 0;
                }
            }
        }
    }
    
    // Place pellets throughout the maze on paths
    function createPellets() {
        pellets = [];
        powerPellets = [];
        lifePellets = []; // Clear life pellets
        specialPowerUps = []; // Clear special power-ups
        foxPowerUps = []; // Clear fox power-ups
        foxPowerUpSpawnTimer = 0; // Reset spawn timer
        
        // FOX MODE: Don't spawn pellets, only fox power-ups will spawn during gameplay
        if (playerCharacter === 'fox') {
            return;
        }
        
        // Add a hint message about strategic power-ups
        const powerUpTips = document.getElementById('power-up-tips');
        if (powerUpTips) {
            powerUpTips.innerHTML = `
                <p>Power-up strategies:</p>
                <p>‚ö° Speed - Find in safe areas away from foxes</p>
                <p>üõ°Ô∏è Shield - Look near fox dens for offensive advantage</p>
                <p>‚ùÑÔ∏è Freeze - Found in pellet-rich areas</p>
            `;
        }
        
        for (let y = 0; y < maze.length; y++) {
            for (let x = 0; x < maze[y].length; x++) {
                if (maze[y][x] === 0) { // If it's a path
                    // Don't place pellets too close to Pac-Man's starting position
                    const startX = Math.floor(pacmanPosition.x / cellSize);
                    const startY = Math.floor(pacmanPosition.y / cellSize);
                    const distance = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                    
                    if (distance > 2) { // Not too close to start
                        // Create power pellets in more strategic locations:
                        // 1. Corner areas (original locations)
                        // 2. Middle points of each wall
                        // 3. Center of the maze
                        // 4. A few random spots for variety
                        if (
                            // Corner areas (original)
                            (x < 3 && y < 3) || 
                            (x < 3 && y > maze.length - 4) || 
                            (x > maze[0].length - 4 && y < 3) || 
                            (x > maze[0].length - 4 && y > maze.length - 4) ||
                            // Middle of each wall
                            (x === Math.floor(maze[0].length / 2) && y <= 2) ||
                            (x === Math.floor(maze[0].length / 2) && y >= maze.length - 3) ||
                            (y === Math.floor(maze.length / 2) && x <= 2) ||
                            (y === Math.floor(maze.length / 2) && x >= maze[0].length - 3) ||
                            // Center of maze
                            (x === Math.floor(maze[0].length / 2) && y === Math.floor(maze.length / 2)) ||
                            // Random additional power pellets (5% chance on eligible path tiles)
                            (Math.random() < 0.05 && (x % 4 === 0 && y % 4 === 0))
                        ) {
                            powerPellets.push({
                                x: x * cellSize + cellSize / 2,
                                y: y * cellSize + cellSize / 2
                            });
                        } 
                        // Regular pellets everywhere else
                        else if (Math.random() > 0.3) { // 70% chance to place a pellet
                            pellets.push({
                                x: x * cellSize + cellSize / 2,
                                y: y * cellSize + cellSize / 2
                            });
                        }
                    }
                }
            }
        }
    }
    
    // Create ghosts at different corners of the maze
    function createBossFox() {
        const mazeWidth = maze[0].length;
        const mazeHeight = maze.length;
        
        console.log("Checking for boss at level:", currentLevel);
        
        // Create boss every 3 levels starting at level 3
        // Using absolute mod to ensure consistent behavior
        if (currentLevel >= 3 && (currentLevel % 3) === 0) {
            console.log("Boss condition met! Creating boss for level:", currentLevel);
            bossActive = true;
            
            // Calculate health based on level
            bossMaxHealth = Math.min(3 + Math.floor(currentLevel / 3), 10); // Max 10 health
            bossHealth = bossMaxHealth;
            
            // Place boss at one of the sides of the maze instead of the center
            // Randomly choose a side: 0=top, 1=right, 2=bottom, 3=left
            const side = Math.floor(Math.random() * 4);
            
            let bossX, bossY;
            let found = false;
            
            // Try to find a valid path position along the chosen side
            switch (side) {
                case 0: // top
                    bossY = 1; // Start at second row to avoid the border wall
                    for (let x = 1; x < mazeWidth - 1 && !found; x++) {
                        if (maze[bossY][x] === 0) {
                            bossX = x;
                            found = true;
                        }
                    }
                    break;
                case 1: // right
                    bossX = mazeWidth - 2; // Second to last column
                    for (let y = 1; y < mazeHeight - 1 && !found; y++) {
                        if (maze[y][bossX] === 0) {
                            bossY = y;
                            found = true;
                        }
                    }
                    break;
                case 2: // bottom
                    bossY = mazeHeight - 2; // Second to last row
                    for (let x = 1; x < mazeWidth - 1 && !found; x++) {
                        if (maze[bossY][x] === 0) {
                            bossX = x;
                            found = true;
                        }
                    }
                    break;
                case 3: // left
                    bossX = 1; // Start at second column
                    for (let y = 1; y < mazeHeight - 1 && !found; y++) {
                        if (maze[y][bossX] === 0) {
                            bossY = y;
                            found = true;
                        }
                    }
                    break;
            }
            
            // If we couldn't find a path on the chosen side, try other sides
            if (!found) {
                for (let altSide = 0; altSide < 4 && !found; altSide++) {
                    if (altSide === side) continue; // Skip the side we already tried
                    
                    switch (altSide) {
                        case 0: // top
                            bossY = 1;
                            for (let x = 1; x < mazeWidth - 1 && !found; x++) {
                                if (maze[bossY][x] === 0) {
                                    bossX = x;
                                    found = true;
                                }
                            }
                            break;
                        case 1: // right
                            bossX = mazeWidth - 2;
                            for (let y = 1; y < mazeHeight - 1 && !found; y++) {
                                if (maze[y][bossX] === 0) {
                                    bossY = y;
                                    found = true;
                                }
                            }
                            break;
                        case 2: // bottom
                            bossY = mazeHeight - 2;
                            for (let x = 1; x < mazeWidth - 1 && !found; x++) {
                                if (maze[bossY][x] === 0) {
                                    bossX = x;
                                    found = true;
                                }
                            }
                            break;
                        case 3: // left
                            bossX = 1;
                            for (let y = 1; y < mazeHeight - 1 && !found; y++) {
                                if (maze[y][bossX] === 0) {
                                    bossY = y;
                                    found = true;
                                }
                            }
                            break;
                    }
                }
            }
            
            // As a last resort, fallback to a random position if no valid side position found
            if (!found) {
                do {
                    bossX = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                    bossY = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                } while (maze[bossY][bossX] !== 0);
            }
            
            bossFox = {
                x: bossX * cellSize + cellSize / 2,
                y: bossY * cellSize + cellSize / 2,
                color: 'gold', // Special color for boss
                direction: { x: 0, y: 0 },
                speed: 1.8 + (currentLevel * 0.1), // Faster than regular ghosts
                frightened: false,
                isBoss: true,
                size: ghostSize * 1.5, // Larger than regular ghosts
                attackCooldown: 0,
                attackRadius: 0,
                dashCooldown: 0,
                dashTarget: null,
                specialAbilityTimer: 0
            };
            
            console.log(`Boss fox spawned at level ${currentLevel} with ${bossHealth} health!`);
            
            // Add boss to ghosts array
            ghosts.push(bossFox);
            
            // Create a special text announcement
            const bossText = document.createElement('div');
            bossText.textContent = '‚ö†Ô∏è BOSS FOX APPEARED! ‚ö†Ô∏è';
            bossText.style.position = 'absolute';
            bossText.style.left = '50%';
            bossText.style.top = '30%';
            bossText.style.transform = 'translate(-50%, -50%)';
            bossText.style.fontSize = '28px';
            bossText.style.fontWeight = 'bold';
            bossText.style.color = '#ff4500';
            bossText.style.zIndex = '1000';
            bossText.style.transition = 'all 1.5s';
            document.body.appendChild(bossText);
            
            // Animate and remove
            setTimeout(() => {
                bossText.style.opacity = '0';
                bossText.style.top = '20%';
                setTimeout(() => {
                    document.body.removeChild(bossText);
                }, 1500);
            }, 2000);
        }
    }

    function createGhosts() {
        const mazeWidth = maze[0].length;
        const mazeHeight = maze.length;
        
        // Ghost colors
        const ghostColors = ['red', 'pink', 'cyan', 'orange'];
        ghosts = [];
        allGhostsEliminated = false;
        bossFox = null;
        bossActive = false;
        
        // FOX PLAYER MODE: Spawn 3 player-controlled foxes at corners (avoiding chicken spawn area)
        if (playerCharacter === 'fox') {
            // Define 3 corner positions for the fox pack (excluding top-left where chicken spawns)
            const foxCorners = [
                { x: mazeWidth - 2, y: 1, color: 'gold' },        // Top-right (Leader)
                { x: 1, y: mazeHeight - 2, color: 'orange' },     // Bottom-left
                { x: mazeWidth - 2, y: mazeHeight - 2, color: 'darkorange' } // Bottom-right
            ];
            
            // Spawn each fox at a corner
            foxCorners.forEach((corner, index) => {
                let foxX = corner.x;
                let foxY = corner.y;
                
                // Make sure the corner is on a path, otherwise find nearest path
                if (maze[foxY][foxX] === 1) {
                    // Find nearest path
                    let found = false;
                    for (let radius = 1; radius < 5 && !found; radius++) {
                        for (let dy = -radius; dy <= radius && !found; dy++) {
                            for (let dx = -radius; dx <= radius && !found; dx++) {
                                const newY = foxY + dy;
                                const newX = foxX + dx;
                                if (newY >= 0 && newY < mazeHeight && newX >= 0 && newX < mazeWidth && maze[newY][newX] === 0) {
                                    foxX = newX;
                                    foxY = newY;
                                    found = true;
                                }
                            }
                        }
                    }
                }
                
                ghosts.push({
                    x: foxX * cellSize + cellSize / 2,
                    y: foxY * cellSize + cellSize / 2,
                    color: corner.color,
                    direction: { x: 0, y: 0 },
                    speed: 2.0,
                    frightened: false,
                    isGhost: false,
                    isPlayer: true // All foxes are player-controlled
                });
            });
            
            console.log(`Fox pack spawned with ${ghosts.length} foxes at corners (avoiding chicken spawn)`);
            return; // Don't spawn other foxes
        }
        
        // CHICKEN PLAYER MODE: Place ghosts in each corner (making sure they're on paths)
        const corners = [
            { x: 1, y: 1 },
            { x: mazeWidth - 2, y: 1 },
            { x: 1, y: mazeHeight - 2 },
            { x: mazeWidth - 2, y: mazeHeight - 2 }
        ];
        
        corners.forEach((corner, i) => {
            // Make sure the corner is a path
            if (maze[corner.y][corner.x] === 1) {
                // Find nearest path
                let found = false;
                for (let radius = 1; radius < 3 && !found; radius++) {
                    for (let dy = -radius; dy <= radius && !found; dy++) {
                        for (let dx = -radius; dx <= radius && !found; dx++) {
                            const newY = corner.y + dy;
                            const newX = corner.x + dx;
                            if (newY >= 0 && newY < mazeHeight && newX >= 0 && newX < mazeWidth && maze[newY][newX] === 0) {
                                corner.x = newX;
                                corner.y = newY;
                                found = true;
                            }
                        }
                    }
                }
            }
            
            ghosts.push({
                x: corner.x * cellSize + cellSize / 2,
                y: corner.y * cellSize + cellSize / 2,
                color: ghostColors[i % ghostColors.length],
                direction: { x: 0, y: 0 },
                speed: 1.5,
                frightened: false,
                isGhost: false  // Regular fox
            });
        });
        
        // Add ghost foxes that can pass through walls (on higher levels)
        if (currentLevel >= 2) {
            const ghostFoxCount = Math.min(currentLevel - 1, 3); // 1 ghost fox on level 2, up to 3
            const ghostFoxColors = ['purple', 'magenta', 'lime'];
            
            // Spawn ghost foxes on the sides of the board
            const sides = [
                { name: 'top', positions: [] },
                { name: 'bottom', positions: [] },
                { name: 'left', positions: [] },
                { name: 'right', positions: [] }
            ];
            
            // Generate valid positions on each side
            for (let i = 1; i < mazeWidth - 1; i++) {
                // Top side
                for (let y = 1; y < 3; y++) {
                    if (maze[y][i] === 0) {
                        sides[0].positions.push({ x: i, y: y });
                        break;
                    }
                }
                // Bottom side
                for (let y = mazeHeight - 3; y < mazeHeight - 1; y++) {
                    if (maze[y][i] === 0) {
                        sides[1].positions.push({ x: i, y: y });
                        break;
                    }
                }
            }
            
            for (let i = 1; i < mazeHeight - 1; i++) {
                // Left side
                for (let x = 1; x < 3; x++) {
                    if (maze[i][x] === 0) {
                        sides[2].positions.push({ x: x, y: i });
                        break;
                    }
                }
                // Right side
                for (let x = mazeWidth - 3; x < mazeWidth - 1; x++) {
                    if (maze[i][x] === 0) {
                        sides[3].positions.push({ x: x, y: i });
                        break;
                    }
                }
            }
            
            // Distribute ghost foxes across the sides
            for (let i = 0; i < ghostFoxCount; i++) {
                const sideIndex = i % 4;
                const side = sides[sideIndex];
                
                if (side.positions.length > 0) {
                    const position = side.positions[Math.floor(Math.random() * side.positions.length)];
                    
                    ghosts.push({
                        x: position.x * cellSize + cellSize / 2,
                        y: position.y * cellSize + cellSize / 2,
                        color: ghostFoxColors[i % ghostFoxColors.length],
                        direction: { x: 0, y: 0 },
                        speed: 1.8,
                        frightened: false,
                        isGhost: true  // This is a ghost fox - can pass through walls
                    });
                }
            }
        }
    }
    
    // Array to hold particle effects for ghost elimination
    let eliminationEffects = [];
    
    // Create particles when a ghost is eliminated
    // Function to create a visual message for extra life
    function createExtraLifeMessage() {
        const x = pacmanPosition.x;
        const y = pacmanPosition.y - 30;
        
        // Create celebratory particles
        const numParticles = 30;
        const colors = ['#FFD700', '#FF5733', '#33FF57', '#33C3FF', 'white'];
        
        for (let i = 0; i < numParticles; i++) {
            eliminationEffects.push({
                x: x,
                y: y,
                radius: Math.random() * 5 + 3,
                color: colors[Math.floor(Math.random() * colors.length)],
                speedX: (Math.random() - 0.5) * 8,
                speedY: (Math.random() - 0.5) * 8,
                life: 30 + Math.random() * 20,
                currentLife: 0,
                text: ['üí´', '‚ú®', '‚≠ê', 'üéâ'][Math.floor(Math.random() * 4)]
            });
        }
        
        // Create text effect
        eliminationEffects.push({
            x: x,
            y: y,
            radius: 0,
            color: '#FFD700',
            speedX: 0,
            speedY: -1.5,
            life: 50,
            currentLife: 0,
            text: 'EXTRA LIFE!',
            isScoreText: true
        });
    }
    
    // Draw the boss fox with special effects and health bar
    function drawBossFox(boss) {
        // Draw boss fox glow/aura
        const glowPulse = Math.sin(Date.now() / 150) * 0.2 + 0.8;
        
        if (powerMode && boss.frightened) {
            // Frightened boss has blue aura but still looks intimidating
            pacmanCtx.fillStyle = 'rgba(30, 100, 255, ' + glowPulse * 0.3 + ')';
            pacmanCtx.beginPath();
            pacmanCtx.arc(boss.x, boss.y, boss.size * 1.8, 0, Math.PI * 2);
            pacmanCtx.fill();
        } else {
            // Boss has fiery red/gold aura
            const gradient = pacmanCtx.createRadialGradient(
                boss.x, boss.y, boss.size * 0.8,
                boss.x, boss.y, boss.size * 1.8
            );
            gradient.addColorStop(0, 'rgba(255, 215, 0, ' + glowPulse * 0.5 + ')');
            gradient.addColorStop(0.5, 'rgba(255, 140, 0, ' + glowPulse * 0.3 + ')');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
            
            pacmanCtx.fillStyle = gradient;
            pacmanCtx.beginPath();
            pacmanCtx.arc(boss.x, boss.y, boss.size * 1.8, 0, Math.PI * 2);
            pacmanCtx.fill();
        }
        
        // Draw boss fox
        pacmanCtx.font = "45px Arial"; // Boss is bigger
        pacmanCtx.textAlign = "center";
        pacmanCtx.textBaseline = "middle";
        
        if (powerMode && boss.frightened) {
            // Even when frightened, boss is still somewhat intimidating
            pacmanCtx.fillText('ü¶ä', boss.x, boss.y);
            pacmanCtx.fillStyle = 'rgba(100, 100, 255, 0.7)';
            pacmanCtx.fillText('üëë', boss.x, boss.y - 25); // Crown slightly blue
        } else {
            // Normal boss state
            pacmanCtx.fillText('ü¶ä', boss.x, boss.y);
            
            // Add a crown to show it's the boss
            pacmanCtx.fillStyle = 'gold';
            pacmanCtx.fillText('üëë', boss.x, boss.y - 25);
        }
        
        // Draw boss attack visualization if attacking
        if (boss.attackCooldown > 0) {
            pacmanCtx.beginPath();
            pacmanCtx.arc(boss.x, boss.y, boss.attackRadius, 0, Math.PI * 2);
            pacmanCtx.strokeStyle = 'rgba(255, 0, 0, ' + (boss.attackCooldown / 20) + ')';
            pacmanCtx.lineWidth = 3;
            pacmanCtx.stroke();
        }
        
        // Draw health bar
        const healthBarWidth = boss.size * 3;
        const healthBarHeight = 8;
        const healthPercentage = bossHealth / bossMaxHealth;
        
        // Health bar background
        pacmanCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        pacmanCtx.fillRect(
            boss.x - healthBarWidth/2,
            boss.y - boss.size - 15,
            healthBarWidth,
            healthBarHeight
        );
        
        // Health bar fill - color changes based on health percentage
        let healthColor;
        if (healthPercentage > 0.6) {
            healthColor = 'lime';
        } else if (healthPercentage > 0.3) {
            healthColor = 'yellow';
        } else {
            healthColor = 'red';
        }
        
        pacmanCtx.fillStyle = healthColor;
        pacmanCtx.fillRect(
            boss.x - healthBarWidth/2,
            boss.y - boss.size - 15,
            healthBarWidth * healthPercentage,
            healthBarHeight
        );
    }
    
    function createEliminationEffect(x, y) {
        const numParticles = 20;
        const colors = ['#FF5733', '#FFC300', '#33FF57', '#33C3FF', '#5733FF', 'white'];
        
        for (let i = 0; i < numParticles; i++) {
            eliminationEffects.push({
                x: x,
                y: y,
                radius: Math.random() * 5 + 3,
                color: colors[Math.floor(Math.random() * colors.length)],
                speedX: (Math.random() - 0.5) * 8,
                speedY: (Math.random() - 0.5) * 8,
                life: 30 + Math.random() * 20,
                currentLife: 0,
                text: ['üí•', 'üí´', '‚ú®', '‚ö°'][Math.floor(Math.random() * 4)]
            });
        }
        
        // Create score popup effect
        eliminationEffects.push({
            x: x,
            y: y - 20,
            radius: 0,
            color: '#FFD700',
            speedX: 0,
            speedY: -1.5,
            life: 50,
            currentLife: 0,
            text: `+${ghostsEaten * 200}`,
            isScoreText: true
        });
    }
    
    // Update and draw elimination effects
    function updateEliminationEffects() {
        if (!eliminationEffects) return; // Safety check
        
        for (let i = eliminationEffects.length - 1; i >= 0; i--) {
            const effect = eliminationEffects[i];
            
            // Skip invalid effects
            if (!effect) {
                eliminationEffects.splice(i, 1);
                continue;
            }
            
            // Update position
            effect.x += effect.speedX;
            effect.y += effect.speedY;
            effect.currentLife++;
            
            // Draw the effect
            pacmanCtx.save();
            
            if (effect.isScoreText) {
                // Draw score text without glow
                const opacity = 1 - (effect.currentLife / effect.life);
                pacmanCtx.font = "bold 16px Arial";
                pacmanCtx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                // No shadow/glow
                pacmanCtx.fillText(effect.text, effect.x, effect.y);
            } else {
                // Draw particle
                const scale = 1 - (effect.currentLife / effect.life * 0.5);
                pacmanCtx.font = `${Math.floor(24 * scale)}px Arial`;
                pacmanCtx.globalAlpha = 1 - (effect.currentLife / effect.life);
                pacmanCtx.fillText(effect.text, effect.x, effect.y);
            }
            
            pacmanCtx.restore();
            
            // Remove expired effects
            if (effect.currentLife >= effect.life) {
                eliminationEffects.splice(i, 1);
            }
        }
    }
    
    // Function to create special power-ups
    function createSpecialPowerUps() {
        specialPowerUps = [];
        
        // Calculate how many power-ups to create based on maze size and level
        const mazeWidth = maze[0].length;
        const mazeHeight = maze.length;
        
        // Create power-ups based on level and strategy
        const numEachType = Math.min(currentLevel, 2); // Maximum 2 of each type
        
        // Define power-up types with strategic purposes
        const powerUpTypes = [
            { 
                type: 'speed', 
                emoji: '‚ö°', 
                color: 'rgba(255, 255, 0, 0.8)', 
                description: 'Speed Boost',
                placementStrategy: 'far-from-ghosts' // Place in areas far from ghosts for escape routes
            },
            { 
                type: 'invincibility', 
                emoji: 'üõ°Ô∏è', 
                color: 'rgba(0, 100, 255, 0.8)', 
                description: 'Shield',
                placementStrategy: 'ghost-heavy' // Place near ghost clusters for offensive plays
            },
            { 
                type: 'freeze', 
                emoji: '‚ùÑÔ∏è', 
                color: 'rgba(0, 255, 255, 0.8)', 
                description: 'Freeze',
                placementStrategy: 'pellet-rich' // Place in areas with many pellets to maximize collection time
            }
        ];
        
        // Get ghost positions for strategic placement
        const ghostPositions = ghosts.map(ghost => ({
            x: Math.floor(ghost.x / cellSize),
            y: Math.floor(ghost.y / cellSize)
        }));
        
        // Create grid representation of pellet density
        const pelletGrid = createPelletDensityGrid();
        
        // Place power-ups strategically
        powerUpTypes.forEach(powerUpType => {
            for (let i = 0; i < numEachType; i++) {
                // Find strategic positions based on power-up type
                let candidatePositions = [];
                
                switch(powerUpType.placementStrategy) {
                    case 'far-from-ghosts':
                        // Speed boost: Place far from ghosts, creating escape routes
                        candidatePositions = findPositionsFarFromGhosts(ghostPositions, 8);
                        break;
                    
                    case 'ghost-heavy':
                        // Invincibility: Place near ghost clusters for offensive play
                        candidatePositions = findPositionsNearGhosts(ghostPositions, 5);
                        break;
                    
                    case 'pellet-rich':
                        // Freeze: Place in areas with high pellet density
                        candidatePositions = findPositionsWithHighPelletDensity(pelletGrid);
                        break;
                }
                
                // If we found valid positions, choose one
                if (candidatePositions.length > 0) {
                    // Choose a position, preferring those farther from the player's start
                    candidatePositions.sort((a, b) => {
                        const startX = Math.floor(pacmanPosition.x / cellSize);
                        const startY = Math.floor(pacmanPosition.y / cellSize);
                        
                        const distA = Math.sqrt(Math.pow(a.x - startX, 2) + Math.pow(a.y - startY, 2));
                        const distB = Math.sqrt(Math.pow(b.x - startX, 2) + Math.pow(b.y - startY, 2));
                        
                        return distB - distA; // Sort by descending distance (farther first)
                    });
                    
                    // Take one of the top 3 positions for variety
                    const posIndex = Math.floor(Math.random() * Math.min(3, candidatePositions.length));
                    const chosenPos = candidatePositions[posIndex];
                    
                    specialPowerUps.push({
                        x: chosenPos.x * cellSize + cellSize / 2,
                        y: chosenPos.y * cellSize + cellSize / 2,
                        type: powerUpType.type,
                        emoji: powerUpType.emoji,
                        color: powerUpType.color,
                        description: powerUpType.description,
                        pulseOffset: 0,
                        pulseDirection: 1
                    });
                } else {
                    // Fallback to semi-random placement if strategic placement fails
                    placeRandomPowerUp(powerUpType);
                }
            }
        });
        
        // Helper function for fallback random placement
        function placeRandomPowerUp(powerUpType) {
            let placed = false;
            let attempts = 0;
            
            while (!placed && attempts < 50) {
                attempts++;
                
                // Get random position
                const x = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                const y = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                
                // Make sure it's a path and not too close to Pac-Man's start position
                if (maze[y][x] === 0) {
                    const startX = Math.floor(pacmanPosition.x / cellSize);
                    const startY = Math.floor(pacmanPosition.y / cellSize);
                    const distance = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                    
                    if (distance > 4) { // Not too close to start
                        specialPowerUps.push({
                            x: x * cellSize + cellSize / 2,
                            y: y * cellSize + cellSize / 2,
                            type: powerUpType.type,
                            emoji: powerUpType.emoji,
                            color: powerUpType.color,
                            description: powerUpType.description,
                            pulseOffset: 0,
                            pulseDirection: 1
                        });
                        placed = true;
                    }
                }
            }
        }
        
        // Helper function to find positions far from all ghosts (for speed boost)
        function findPositionsFarFromGhosts(ghostPositions, minDistance) {
            const candidates = [];
            
            for (let y = 1; y < mazeHeight - 1; y++) {
                for (let x = 1; x < mazeWidth - 1; x++) {
                    // Skip walls
                    if (maze[y][x] !== 0) continue;
                    
                    // Calculate minimum distance to any ghost
                    let minGhostDist = Number.MAX_VALUE;
                    for (const ghostPos of ghostPositions) {
                        const dist = Math.sqrt(Math.pow(x - ghostPos.x, 2) + Math.pow(y - ghostPos.y, 2));
                        minGhostDist = Math.min(minGhostDist, dist);
                    }
                    
                    // If far enough from all ghosts
                    if (minGhostDist >= minDistance) {
                        candidates.push({ x, y });
                    }
                }
            }
            
            return candidates;
        }
        
        // Helper function to find positions near ghost clusters (for invincibility)
        function findPositionsNearGhosts(ghostPositions, maxDistance) {
            const candidates = [];
            
            // Skip if no ghosts
            if (ghostPositions.length === 0) return candidates;
            
            for (let y = 1; y < mazeHeight - 1; y++) {
                for (let x = 1; x < mazeWidth - 1; x++) {
                    // Skip walls
                    if (maze[y][x] !== 0) continue;
                    
                    // Count ghosts within the specified distance
                    let nearbyGhosts = 0;
                    for (const ghostPos of ghostPositions) {
                        const dist = Math.sqrt(Math.pow(x - ghostPos.x, 2) + Math.pow(y - ghostPos.y, 2));
                        if (dist <= maxDistance) nearbyGhosts++;
                    }
                    
                    // If there are nearby ghosts, consider this position
                    if (nearbyGhosts > 0) {
                        // Score based on number of nearby ghosts
                        candidates.push({ 
                            x, 
                            y, 
                            score: nearbyGhosts 
                        });
                    }
                }
            }
            
            // Sort by score (most ghosts nearby first)
            candidates.sort((a, b) => b.score - a.score);
            
            // Return top candidates
            return candidates.slice(0, Math.min(10, candidates.length));
        }
        
        // Helper function to create a grid representing pellet density
        function createPelletDensityGrid() {
            const densityGrid = Array(mazeHeight).fill().map(() => Array(mazeWidth).fill(0));
            
            // Count regular pellets and power pellets in each area
            for (const pellet of pellets) {
                const x = Math.floor(pellet.x / cellSize);
                const y = Math.floor(pellet.y / cellSize);
                
                if (x >= 0 && x < mazeWidth && y >= 0 && y < mazeHeight) {
                    // Increment density at this point and surrounding cells
                    for (let dy = -2; dy <= 2; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < mazeWidth && ny >= 0 && ny < mazeHeight) {
                                const weight = 3 - Math.max(Math.abs(dx), Math.abs(dy));
                                if (weight > 0) densityGrid[ny][nx] += weight;
                            }
                        }
                    }
                }
            }
            
            // Power pellets count extra
            for (const pellet of powerPellets) {
                const x = Math.floor(pellet.x / cellSize);
                const y = Math.floor(pellet.y / cellSize);
                
                if (x >= 0 && x < mazeWidth && y >= 0 && y < mazeHeight) {
                    // Increment density at this point and surrounding cells
                    for (let dy = -3; dy <= 3; dy++) {
                        for (let dx = -3; dx <= 3; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < mazeWidth && ny >= 0 && ny < mazeHeight) {
                                const weight = 4 - Math.max(Math.abs(dx), Math.abs(dy));
                                if (weight > 0) densityGrid[ny][nx] += weight * 2;
                            }
                        }
                    }
                }
            }
            
            return densityGrid;
        }
        
        // Helper function to find positions with high pellet density (for freeze)
        function findPositionsWithHighPelletDensity(densityGrid) {
            const candidates = [];
            
            for (let y = 1; y < mazeHeight - 1; y++) {
                for (let x = 1; x < mazeWidth - 1; x++) {
                    // Skip walls
                    if (maze[y][x] !== 0) continue;
                    
                    // Consider positions with good pellet density
                    if (densityGrid[y][x] > 5) {
                        candidates.push({ 
                            x, 
                            y, 
                            score: densityGrid[y][x] 
                        });
                    }
                }
            }
            
            // Sort by pellet density score
            candidates.sort((a, b) => b.score - a.score);
            
            // Return top candidates
            return candidates.slice(0, Math.min(15, candidates.length));
        }
    }
    
    function initPacmanGame(resetScore = true) {
        console.log('Initializing Pac-Man game...');
        
        // Clean up any existing ghost and chicken GIF elements
        const existingGhostGifs = document.querySelectorAll('.pacman-ghost-gif');
        existingGhostGifs.forEach(element => element.remove());
        
        const existingChickenGif = document.querySelector('.pacman-chicken-gif');
        if (existingChickenGif) {
            existingChickenGif.remove();
            pacmanChickenElement = null;
        }
        
        // If resetScore is true, reset score, lives, and level
        if (resetScore) {
            if (playerCharacter === 'chicken') {
                pacmanScore = 0;
                pacmanLives = 3;
            } else {
                // Fox mode: score is based on how fast you catch the chicken
                pacmanScore = 0;
                pacmanLives = 1; // Fox has 1 attempt per level
            }
            currentLevel = 1;
            nextLifeAt = 10000; // Reset next life threshold
            gameTimeRemaining = 120; // Reset timer to 2 minutes
            gameStartTime = Date.now();
            lastTimerUpdate = Date.now();
        }
        // If not resetting score, just update the timer reference (level transition)
        else {
            lastTimerUpdate = Date.now(); // Update timer reference for smooth transition
        }
        
        // Set starting position based on character
        if (playerCharacter === 'fox') {
            // In fox mode, chicken starts at a corner FAR from fox spawn
            // Find a path position in top-left area
            let chickenStartX = 1;
            let chickenStartY = 1;
            
            // Find first valid path in top-left corner
            for (let y = 1; y < 5 && chickenStartY === 1; y++) {
                for (let x = 1; x < 5 && chickenStartX === 1; x++) {
                    if (maze && maze[y] && maze[y][x] === 0) {
                        chickenStartX = x;
                        chickenStartY = y;
                        break;
                    }
                }
            }
            
            pacmanPosition = { 
                x: chickenStartX * cellSize + cellSize / 2, 
                y: chickenStartY * cellSize + cellSize / 2 
            };
            
            // Spawn protection - 1 second to prevent instant collision
            spawnProtectionTime = Date.now() + 1000;
            
            console.log('Fox mode initialized. Chicken at:', pacmanPosition, 'Protection until:', new Date(spawnProtectionTime));
        } else {
            // In chicken mode, player starts at center
            pacmanPosition = { x: 400, y: 300 }; // Center of the canvas
            spawnProtectionTime = 0; // No protection needed in chicken mode
        }
        
        pacmanDirection = { x: 0, y: 0 };
        powerMode = false;
        ghostsEaten = 0;
        eliminationEffects = [];
        
        // Reset power-up states
        speedBoostActive = false;
        invincibilityActive = false;
        freezeActive = false;
        
        // Remove next level button if it exists
        if (nextLevelButton) {
            try {
                document.body.removeChild(nextLevelButton);
            } catch (e) {
                console.error('Error removing next level button:', e);
            }
            nextLevelButton = null;
        }
        
        // Initialize maze with error handling
        try {
            createMaze();
            console.log('Maze created:', maze.length, 'rows');
            
            // Only create pellets and power-ups in chicken mode
            if (playerCharacter === 'chicken') {
                createPellets();
                console.log('Pellets created:', pellets.length, 'regular,', powerPellets.length, 'power');
                createSpecialPowerUps();
                console.log('Special power-ups created:', specialPowerUps.length);
            } else {
                // Fox mode: clear any existing pellets and power-ups
                pellets = [];
                powerPellets = [];
                lifePellets = [];
                specialPowerUps = [];
                console.log('Fox mode: No pellets created');
            }
            
            createGhosts();
            console.log('Ghosts created:', ghosts.length);
            console.log("About to check for boss fox at level:", currentLevel);
            createBossFox(); // Add boss fox if it's a boss level
            if (bossActive) {
                console.log('Boss fox created with', bossHealth, 'health!');
            } else {
                console.log('No boss fox created at level:', currentLevel);
            }
        } catch (error) {
            console.error('Error during game initialization:', error);
            // Create a basic maze as fallback
            const mazeWidth = Math.floor(pacmanCanvas.width / cellSize);
            const mazeHeight = Math.floor(pacmanCanvas.height / cellSize);
            maze = [];
            for (let y = 0; y < mazeHeight; y++) {
                const row = [];
                for (let x = 0; x < mazeWidth; x++) {
                    row.push((x === 0 || y === 0 || x === mazeWidth - 1 || y === mazeHeight - 1) ? 1 : 0);
                }
                maze.push(row);
            }
        }
        
        pacmanScoreSpan.textContent = pacmanScore;
        pacmanLivesSpan.textContent = pacmanLives;
        
        // Update timer display
        const minutes = Math.floor(gameTimeRemaining / 60);
        const seconds = gameTimeRemaining % 60;
        pacmanTimerSpan.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        pacmanTimerSpan.style.color = '#ff4500';
        
        // Display current level with error handling
        try {
            document.getElementById('pacman-level').textContent = currentLevel;
        } catch (e) {
            console.error('Error updating level display:', e);
        }
    }
    
    function drawPacman() {
        // Create or update the chicken GIF DOM element if not already created
        if (pacmanChickenGifLoaded && !pacmanChickenElement) {
            pacmanChickenElement = document.createElement('img');
            pacmanChickenElement.src = pacmanChickenGifUrl;
            pacmanChickenElement.style.position = 'absolute';
            pacmanChickenElement.style.width = pacmanChickenSize + 'px';
            pacmanChickenElement.style.height = pacmanChickenSize + 'px';
            pacmanChickenElement.style.pointerEvents = 'none';
            pacmanChickenElement.style.zIndex = '5';
            pacmanChickenElement.classList.add('pacman-chicken-gif');
            
            // Add to canvas container
            const canvasContainer = pacmanCanvas.parentElement;
            if (canvasContainer.style.position !== 'relative') {
                canvasContainer.style.position = 'relative';
            }
            canvasContainer.appendChild(pacmanChickenElement);
        }
        
        // Update the chicken GIF element position and rotation if it exists
        if (pacmanChickenElement && pacmanChickenGifLoaded) {
            const canvasRect = pacmanCanvas.getBoundingClientRect();
            const containerRect = pacmanCanvas.parentElement.getBoundingClientRect();
            
            const leftPos = canvasRect.left - containerRect.left + pacmanPosition.x - pacmanChickenSize/2;
            const topPos = canvasRect.top - containerRect.top + pacmanPosition.y - pacmanChickenSize/2;
            
            pacmanChickenElement.style.left = leftPos + 'px';
            pacmanChickenElement.style.top = topPos + 'px';
            
            // Calculate rotation based on direction
            let rotation = 0;
            if (pacmanDirection.x > 0) rotation = 0; // Right - face right
            else if (pacmanDirection.x < 0) rotation = 0; // Left - still face right
            else if (pacmanDirection.y > 0) rotation = Math.PI / 2; // Down - face down
            else if (pacmanDirection.y < 0) rotation = -Math.PI / 2; // Up - face up
            
            pacmanChickenElement.style.transform = `rotate(${rotation}rad)`;
            pacmanChickenElement.style.transformOrigin = 'center center';
        }
        
        // Draw effects on canvas (shield, speed boost, etc.)
        pacmanCtx.save();
        pacmanCtx.translate(pacmanPosition.x, pacmanPosition.y);
        
        // Apply visual effects for active power-ups
        if (invincibilityActive) {
            // Shield effect for invincibility
            pacmanCtx.beginPath();
            pacmanCtx.arc(0, 0, pacmanChickenSize * 1.6, 0, Math.PI * 2);
            pacmanCtx.fillStyle = 'rgba(0, 100, 255, 0.15)';
            pacmanCtx.fill();
            pacmanCtx.strokeStyle = 'rgba(0, 100, 255, 0.5)';
            pacmanCtx.lineWidth = 1;
            pacmanCtx.stroke();
            
            // Shield outline
            pacmanCtx.beginPath();
            const shieldPulse = Math.sin(Date.now() / 150) * 2;
            pacmanCtx.arc(0, 0, pacmanChickenSize * 1.3 + shieldPulse, 0, Math.PI * 2);
            pacmanCtx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
            pacmanCtx.stroke();
        }
        
        // Spawn protection effect (Fox mode)
        if (playerCharacter === 'fox' && Date.now() < spawnProtectionTime) {
            // Green shield effect during spawn protection
            pacmanCtx.beginPath();
            pacmanCtx.arc(0, 0, pacmanChickenSize * 1.6, 0, Math.PI * 2);
            pacmanCtx.fillStyle = 'rgba(0, 255, 0, 0.15)';
            pacmanCtx.fill();
            pacmanCtx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            pacmanCtx.lineWidth = 2;
            pacmanCtx.stroke();
            
            // Pulsing outline
            pacmanCtx.beginPath();
            const protectionPulse = Math.sin(Date.now() / 100) * 3;
            pacmanCtx.arc(0, 0, pacmanChickenSize * 1.3 + protectionPulse, 0, Math.PI * 2);
            pacmanCtx.strokeStyle = 'rgba(100, 255, 100, 0.7)';
            pacmanCtx.lineWidth = 2;
            pacmanCtx.stroke();
            
            // "READY!" text
            pacmanCtx.font = 'bold 14px Arial';
            pacmanCtx.fillStyle = 'rgba(0, 255, 0, 0.9)';
            pacmanCtx.textAlign = 'center';
            pacmanCtx.textBaseline = 'middle';
            pacmanCtx.fillText('READY!', 0, -30);
        }
        
        // Speed boost effect (simplified)
        if (speedBoostActive) {
            // Simple speed indicator
            if (pacmanDirection.x !== 0 || pacmanDirection.y !== 0) {
                pacmanCtx.font = '12px Arial';
                pacmanCtx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                pacmanCtx.textAlign = 'center';
                pacmanCtx.textBaseline = 'middle';
                
                // Place the lightning bolt symbol based on direction
                if (pacmanDirection.x > 0) { // Moving right
                    pacmanCtx.fillText('‚ö°', -15, 0);
                } else if (pacmanDirection.x < 0) { // Moving left
                    pacmanCtx.fillText('‚ö°', 15, 0);
                } else if (pacmanDirection.y > 0) { // Moving down
                    pacmanCtx.fillText('‚ö°', 0, -15);
                } else if (pacmanDirection.y < 0) { // Moving up
                    pacmanCtx.fillText('‚ö°', 0, 15);
                }
            }
        }
        
        // Draw a subtle placeholder circle on canvas where the chicken is
        pacmanCtx.beginPath();
        pacmanCtx.arc(0, 0, pacmanChickenSize/2, 0, Math.PI * 2);
        pacmanCtx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        pacmanCtx.fill();
        
        pacmanCtx.restore();
    }
    
    function drawGhosts() {
        ghosts.forEach(ghost => {
            pacmanCtx.save();
            
            // Check if this ghost is a boss
            if (ghost.isBoss) {
                drawBossFox(ghost);
                pacmanCtx.restore();
                return;
            }
            
            // Create or update GIF element for this ghost if GIF is loaded and NOT in frightened mode
            if (pacmanFoxGifLoaded && !ghost.gifElement && !(powerMode && ghost.frightened)) {
                ghost.gifElement = document.createElement('img');
                ghost.gifElement.src = pacmanFoxGifUrl;
                ghost.gifElement.style.position = 'absolute';
                ghost.gifElement.style.width = pacmanFoxSize + 'px';
                ghost.gifElement.style.height = pacmanFoxSize + 'px';
                ghost.gifElement.style.pointerEvents = 'none';
                ghost.gifElement.style.zIndex = '5';
                ghost.gifElement.classList.add('pacman-ghost-gif');
                ghost.gifElement.id = 'ghost_' + ghost.id;
                
                // Add to canvas container
                const canvasContainer = pacmanCanvas.parentElement;
                if (canvasContainer.style.position !== 'relative') {
                    canvasContainer.style.position = 'relative';
                }
                canvasContainer.appendChild(ghost.gifElement);
            }
            
            // Remove GIF element if ghost becomes frightened
            if (powerMode && ghost.frightened && ghost.gifElement) {
                ghost.gifElement.remove();
                ghost.gifElement = null;
            }
            
            // Update GIF element position if it exists and ghost is not frightened
            if (ghost.gifElement && pacmanFoxGifLoaded && !(powerMode && ghost.frightened)) {
                const canvasStyle = window.getComputedStyle(pacmanCanvas);
                const canvasMarginLeft = parseInt(canvasStyle.marginLeft) || 0;
                const canvasMarginTop = parseInt(canvasStyle.marginTop) || 0;
                const canvasBorderLeft = parseInt(canvasStyle.borderLeftWidth) || 0;
                const canvasBorderTop = parseInt(canvasStyle.borderTopWidth) || 0;
                const canvasRect = pacmanCanvas.getBoundingClientRect();
                
                // Update size if fox has size boost
                const displaySize = ghost.sizeBoost ? pacmanFoxSize * 1.5 : pacmanFoxSize;
                ghost.gifElement.style.width = displaySize + 'px';
                ghost.gifElement.style.height = displaySize + 'px';
                
                const leftPos = canvasRect.left - pacmanCanvas.parentElement.getBoundingClientRect().left + ghost.x - displaySize/2;
                const topPos = canvasRect.top - pacmanCanvas.parentElement.getBoundingClientRect().top + ghost.y - displaySize/2;
                
                ghost.gifElement.style.left = leftPos + 'px';
                ghost.gifElement.style.top = topPos + 'px';
                
                // Apply rotation based on movement direction
                let rotation = 0;
                if (ghost.vx > 0) rotation = 0; // Right - face right
                else if (ghost.vx < 0) rotation = 0; // Left - still face right
                else if (ghost.vy > 0) rotation = Math.PI / 2; // Down - face down
                else if (ghost.vy < 0) rotation = -Math.PI / 2; // Up - face up
                
                if (rotation !== 0) {
                    ghost.gifElement.style.transform = `rotate(${rotation}rad)`;
                    ghost.gifElement.style.transformOrigin = 'center center';
                }
            }
            
            // Draw fox or placeholder
            pacmanCtx.textAlign = "center";
            pacmanCtx.textBaseline = "middle";
            
            // Use fox GIF - either normal fox or blue (scared) fox
            if (powerMode && ghost.frightened) {
                // Blue tint effect for frightened foxes
                pacmanCtx.globalAlpha = 1.0; // Full opacity
                pacmanCtx.fillStyle = 'rgba(30, 144, 255, 0.4)';
                pacmanCtx.beginPath();
                pacmanCtx.arc(ghost.x, ghost.y, ghostSize * 1.5, 0, Math.PI * 2);
                pacmanCtx.fill();
                
                // Create a pulsing effect for the frightened fox
                const pulseSize = Math.sin(Date.now() / 200) * 2;
                
                // Draw static fox GIF (frozen first frame) with canvas drawImage
                pacmanCtx.translate(ghost.x, ghost.y);
                if (pacmanFoxGifLoaded) {
                    // Draw just the first frame of the GIF (static)
                    pacmanCtx.drawImage(pacmanFoxGif, -pacmanFoxSize/2, -pacmanFoxSize/2 - pulseSize, pacmanFoxSize, pacmanFoxSize);
                } else {
                    // Fallback to emoji
                    pacmanCtx.font = `${30 + pulseSize}px Arial`;
                    pacmanCtx.fillText('ü¶ä', 0, 0);
                }
                pacmanCtx.translate(-ghost.x, -ghost.y);
                
                // Add scared expression with animation
                pacmanCtx.fillStyle = 'white';
                pacmanCtx.shadowColor = 'red';
                pacmanCtx.shadowBlur = 5;
                pacmanCtx.font = '14px Arial';
                pacmanCtx.fillText('‚ùó', ghost.x, ghost.y - 20 - Math.abs(pulseSize));
            } else {
                // Draw placeholder circle for regular fox (GIF is handled by DOM element)
                pacmanCtx.beginPath();
                pacmanCtx.arc(ghost.x, ghost.y, pacmanFoxSize/2, 0, Math.PI * 2);
                pacmanCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                pacmanCtx.fill();
                pacmanCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                pacmanCtx.lineWidth = 1;
                pacmanCtx.stroke();
                
                // Draw extra effect for ghost foxes (ethereal glow)
                if (ghost.isGhost) {
                    pacmanCtx.beginPath();
                    const ghostGlowSize = Math.sin(Date.now() / 200) * 3 + 8;
                    pacmanCtx.arc(ghost.x, ghost.y, pacmanFoxSize/2 + ghostGlowSize, 0, Math.PI * 2);
                    pacmanCtx.strokeStyle = 'rgba(200, 100, 255, 0.4)';
                    pacmanCtx.lineWidth = 2;
                    pacmanCtx.stroke();
                }
                
                // Draw power-up effects
                if (ghost.speedBoost) {
                    // Speed boost - red/orange trail effect
                    pacmanCtx.beginPath();
                    const speedGlow = Math.sin(Date.now() / 100) * 5 + 10;
                    pacmanCtx.arc(ghost.x, ghost.y, (ghost.size || ghostSize) + speedGlow, 0, Math.PI * 2);
                    pacmanCtx.strokeStyle = 'rgba(255, 69, 0, 0.6)';
                    pacmanCtx.lineWidth = 3;
                    pacmanCtx.stroke();
                    
                    // Add flame particles
                    pacmanCtx.fillStyle = 'rgba(255, 100, 0, 0.8)';
                    pacmanCtx.font = '16px Arial';
                    const flameOffset = Math.sin(Date.now() / 150) * 3;
                    pacmanCtx.fillText('üî•', ghost.x - 15, ghost.y - 15 + flameOffset);
                }
                
                if (ghost.sizeBoost) {
                    // Size boost - pulsing golden aura
                    pacmanCtx.beginPath();
                    const sizePulse = Math.sin(Date.now() / 150) * 3 + 8;
                    pacmanCtx.arc(ghost.x, ghost.y, (ghost.size || ghostSize) + sizePulse, 0, Math.PI * 2);
                    pacmanCtx.strokeStyle = 'rgba(255, 215, 0, 0.7)';
                    pacmanCtx.lineWidth = 3;
                    pacmanCtx.stroke();
                    
                    // Add muscle emoji
                    pacmanCtx.fillStyle = 'rgba(255, 215, 0, 1)';
                    pacmanCtx.font = '16px Arial';
                    const muscleOffset = Math.sin(Date.now() / 150) * 2;
                    pacmanCtx.fillText('üí™', ghost.x + 15, ghost.y - 15 + muscleOffset);
                }
                
                if (ghost.rageMode) {
                    // RAGE MODE - Intense red/black pulsing aura with multiple rings
                    const rageTime = Date.now() / 100;
                    
                    // Inner red ring
                    pacmanCtx.beginPath();
                    const ragePulse1 = Math.sin(rageTime) * 5 + 12;
                    pacmanCtx.arc(ghost.x, ghost.y, (ghost.size || ghostSize) + ragePulse1, 0, Math.PI * 2);
                    pacmanCtx.strokeStyle = 'rgba(255, 0, 0, 0.9)';
                    pacmanCtx.lineWidth = 4;
                    pacmanCtx.stroke();
                    
                    // Outer dark ring
                    pacmanCtx.beginPath();
                    const ragePulse2 = Math.sin(rageTime + Math.PI) * 5 + 18;
                    pacmanCtx.arc(ghost.x, ghost.y, (ghost.size || ghostSize) + ragePulse2, 0, Math.PI * 2);
                    pacmanCtx.strokeStyle = 'rgba(139, 0, 0, 0.8)';
                    pacmanCtx.lineWidth = 3;
                    pacmanCtx.stroke();
                    
                    // Rage particles
                    pacmanCtx.fillStyle = 'rgba(255, 0, 0, 1)';
                    pacmanCtx.font = '18px Arial';
                    const rage1 = Math.sin(Date.now() / 120) * 4;
                    const rage2 = Math.cos(Date.now() / 140) * 4;
                    pacmanCtx.fillText('üòà', ghost.x - 18, ghost.y - 18 + rage1);
                    pacmanCtx.fillText('üí¢', ghost.x + 18, ghost.y - 18 + rage2);
                }
                
                if (ghost.isClone) {
                    // Clone indicator - subtle blue shimmer
                    pacmanCtx.beginPath();
                    const clonePulse = Math.sin(Date.now() / 200) * 2 + 5;
                    pacmanCtx.arc(ghost.x, ghost.y, (ghost.size || ghostSize) + clonePulse, 0, Math.PI * 2);
                    pacmanCtx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
                    pacmanCtx.lineWidth = 2;
                    pacmanCtx.stroke();
                    
                    // Clone emoji
                    pacmanCtx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                    pacmanCtx.font = '14px Arial';
                    pacmanCtx.fillText('üë•', ghost.x + 15, ghost.y + 18);
                }
            }
            
            pacmanCtx.restore();
        });
    }
    
    function drawMinimap() {
        // Draw minimap to separate canvas
        const minimapWidth = pacmanMinimapCanvas.width - 10;
        const minimapHeight = pacmanMinimapCanvas.height - 50;
        const minimapX = 5;
        const minimapY = 5;
        const minimapCellSize = minimapWidth / maze[0].length;
        
        // Clear minimap canvas
        pacmanMinimapCtx.fillStyle = 'rgba(0, 0, 0, 1)';
        pacmanMinimapCtx.fillRect(0, 0, pacmanMinimapCanvas.width, pacmanMinimapCanvas.height);
        
        // Draw minimap border
        pacmanMinimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        pacmanMinimapCtx.lineWidth = 2;
        pacmanMinimapCtx.strokeRect(minimapX, minimapY, minimapWidth, minimapHeight);
        
        // Draw walls on minimap
        for (let y = 0; y < maze.length; y++) {
            for (let x = 0; x < maze[y].length; x++) {
                if (maze[y][x] === 1) { // Wall
                    const isGhostPassable = ghostWalls[y] && ghostWalls[y][x] === 1;
                    
                    // Ghost-passable walls are purple, regular walls are blue
                    pacmanMinimapCtx.fillStyle = isGhostPassable ? 'rgba(200, 100, 255, 0.8)' : 'rgba(50, 50, 200, 0.8)';
                    pacmanMinimapCtx.fillRect(
                        minimapX + x * minimapCellSize,
                        minimapY + y * minimapCellSize,
                        minimapCellSize,
                        minimapCellSize
                    );
                }
            }
        }
        
        // Draw chicken position on minimap
        const chickenMiniX = minimapX + (pacmanPosition.x / pacmanCanvas.width) * minimapWidth;
        const chickenMiniY = minimapY + (pacmanPosition.y / pacmanCanvas.height) * minimapHeight;
        pacmanMinimapCtx.fillStyle = 'rgba(255, 255, 0, 1)';
        pacmanMinimapCtx.beginPath();
        pacmanMinimapCtx.arc(chickenMiniX, chickenMiniY, 3, 0, Math.PI * 2);
        pacmanMinimapCtx.fill();
        
        // Draw foxes on minimap
        ghosts.forEach(ghost => {
            const foxMiniX = minimapX + (ghost.x / pacmanCanvas.width) * minimapWidth;
            const foxMiniY = minimapY + (ghost.y / pacmanCanvas.height) * minimapHeight;
            pacmanMinimapCtx.fillStyle = ghost.isGhost ? 'rgba(200, 100, 255, 1)' : 'rgba(255, 100, 100, 1)';
            pacmanMinimapCtx.beginPath();
            pacmanMinimapCtx.arc(foxMiniX, foxMiniY, 2, 0, Math.PI * 2);
            pacmanMinimapCtx.fill();
        });
        
        // Draw legend
        const legendY = minimapHeight + 15;
        pacmanMinimapCtx.font = '9px Arial';
        pacmanMinimapCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        pacmanMinimapCtx.textAlign = 'left';
        pacmanMinimapCtx.fillText('Legend:', minimapX + 5, legendY);
        
        pacmanMinimapCtx.fillStyle = 'rgba(200, 100, 255, 0.8)';
        pacmanMinimapCtx.fillRect(minimapX + 5, legendY + 5, 8, 8);
        pacmanMinimapCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        pacmanMinimapCtx.fillText('Ghost', minimapX + 17, legendY + 12);
        
        pacmanMinimapCtx.fillStyle = 'rgba(50, 50, 200, 0.8)';
        pacmanMinimapCtx.fillRect(minimapX + 5, legendY + 15, 8, 8);
        pacmanMinimapCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        pacmanMinimapCtx.fillText('Wall', minimapX + 17, legendY + 22);
    }
    
    function drawMaze() {
        // Ensure the maze exists and has content
        if (!maze || maze.length === 0) {
            console.error('Maze is empty or undefined');
            // Draw a default background so the screen isn't black
            pacmanCtx.fillStyle = '#EEEEEE';
            pacmanCtx.fillRect(0, 0, pacmanCanvas.width, pacmanCanvas.height);
            return;
        }
        
        // Draw the background
        pacmanCtx.fillStyle = '#EEEEEE';
        pacmanCtx.fillRect(0, 0, pacmanCanvas.width, pacmanCanvas.height);
        
        for (let y = 0; y < maze.length; y++) {
            for (let x = 0; x < maze[y].length; x++) {
                if (maze[y][x] === 1) { // Wall
                    // All walls are the same color (classic blue)
                    const gradient = pacmanCtx.createLinearGradient(
                        x * cellSize, y * cellSize,
                        x * cellSize + cellSize, y * cellSize + cellSize
                    );
                    gradient.addColorStop(0, '#1919A6'); // Classic Pac-Man blue
                    gradient.addColorStop(0.5, '#2929D6'); // Lighter blue for center
                    gradient.addColorStop(1, '#1919A6'); // Back to classic blue
                    
                    pacmanCtx.fillStyle = gradient;
                    pacmanCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    
                    // Add subtle border for definition
                    pacmanCtx.strokeStyle = '#0000FF';
                    pacmanCtx.lineWidth = 1;
                    pacmanCtx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
    }
    
    function drawPellets() {
        // Draw special life pellets (hearts)
        lifePellets.forEach(pellet => {
            // Calculate pulse effect
            if (!pellet.pulseOffset) pellet.pulseOffset = 0;
            if (!pellet.pulseDirection) pellet.pulseDirection = 1;
            
            pellet.pulseOffset += 0.1 * pellet.pulseDirection;
            if (pellet.pulseOffset > 2 || pellet.pulseOffset < 0) {
                pellet.pulseDirection *= -1;
            }
            
            pacmanCtx.save();
            pacmanCtx.shadowColor = 'rgba(255, 0, 0, 0.8)';
            pacmanCtx.shadowBlur = 15;
            
            // Use heart emoji
            pacmanCtx.font = `${20 + pellet.pulseOffset}px Arial`;
            pacmanCtx.textAlign = 'center';
            pacmanCtx.textBaseline = 'middle';
            pacmanCtx.fillText('‚ù§Ô∏è', pellet.x, pellet.y);
            
            // Add glowing effect
            pacmanCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            pacmanCtx.beginPath();
            pacmanCtx.arc(pellet.x, pellet.y, 10 + pellet.pulseOffset * 1.5, 0, Math.PI * 2);
            pacmanCtx.fill();
            pacmanCtx.restore();
        });
        
        // Draw regular pellets as corn (chicken feed) with enhanced appearance
        pellets.forEach(pellet => {
            pacmanCtx.save();
            pacmanCtx.font = "18px Arial"; // Slightly larger size
            pacmanCtx.textAlign = "center";
            pacmanCtx.textBaseline = "middle";
            
            // Add a subtle yellow glow for corn
            pacmanCtx.shadowColor = 'rgba(255, 215, 0, 0.7)';
            pacmanCtx.shadowBlur = 5;
            pacmanCtx.fillText('üåΩ', pellet.x, pellet.y);
            pacmanCtx.restore();
        });
        
        // Draw power pellets as special chicken feed bag with enhanced pulsing effect
        const pulseOffset = Math.sin(Date.now() / 200) * 3; // More pronounced pulse
        powerPellets.forEach(pellet => {
            pacmanCtx.save();
            const fontSize = 22 + pulseOffset; // Larger base size
            pacmanCtx.font = `${fontSize}px Arial`;
            pacmanCtx.textAlign = "center";
            pacmanCtx.textBaseline = "middle";
            
            // Vibrant golden glow for power pellets
            pacmanCtx.shadowColor = 'rgba(255, 215, 0, 0.9)';
            pacmanCtx.shadowBlur = 15;
            
            // Use grain emoji as special chicken feed
            pacmanCtx.fillText('üåæ', pellet.x, pellet.y);
            
            // Add stronger golden glow with animation
            pacmanCtx.fillStyle = 'rgba(255, 215, 0, 0.5)';
            pacmanCtx.beginPath();
            pacmanCtx.arc(pellet.x, pellet.y, powerPelletSize + pulseOffset * 1.5, 0, Math.PI * 2);
            pacmanCtx.fill();
            pacmanCtx.restore();
        });
        
        // Draw special power-ups with distinctive appearances
        specialPowerUps.forEach(powerUp => {
            // Calculate subtle pulse effect for each power-up (just for size variation)
            if (!powerUp.pulseOffset) powerUp.pulseOffset = 0;
            if (!powerUp.pulseDirection) powerUp.pulseDirection = 1;
            
            powerUp.pulseOffset += 0.05 * powerUp.pulseDirection;
            if (powerUp.pulseOffset > 1 || powerUp.pulseOffset < 0) {
                powerUp.pulseDirection *= -1;
            }
            
            pacmanCtx.save();
            
            // Draw a small subtle background circle
            pacmanCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            pacmanCtx.beginPath();
            pacmanCtx.arc(powerUp.x, powerUp.y, 14, 0, Math.PI * 2);
            pacmanCtx.fill();
            
            // Draw the emoji without glow effects
            pacmanCtx.font = `${22 + powerUp.pulseOffset}px Arial`;
            pacmanCtx.textAlign = 'center';
            pacmanCtx.textBaseline = 'middle';
            pacmanCtx.fillText(powerUp.emoji, powerUp.x, powerUp.y);
            
            pacmanCtx.restore();
        });
        
        // Draw fox power-ups with distinctive red/orange styling
        foxPowerUps.forEach(powerUp => {
            // Calculate pulse effect
            if (!powerUp.pulseOffset) powerUp.pulseOffset = 0;
            if (!powerUp.pulseDirection) powerUp.pulseDirection = 1;
            
            powerUp.pulseOffset += 0.05 * powerUp.pulseDirection;
            if (powerUp.pulseOffset > 1 || powerUp.pulseOffset < 0) {
                powerUp.pulseDirection *= -1;
            }
            
            pacmanCtx.save();
            
            // Draw a red/orange background circle
            pacmanCtx.fillStyle = 'rgba(255, 69, 0, 0.4)';
            pacmanCtx.beginPath();
            pacmanCtx.arc(powerUp.x, powerUp.y, 14, 0, Math.PI * 2);
            pacmanCtx.fill();
            
            // Add a danger ring
            pacmanCtx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
            pacmanCtx.lineWidth = 2;
            pacmanCtx.beginPath();
            pacmanCtx.arc(powerUp.x, powerUp.y, 14 + powerUp.pulseOffset * 2, 0, Math.PI * 2);
            pacmanCtx.stroke();
            
            // Draw the emoji
            pacmanCtx.font = `${22 + powerUp.pulseOffset}px Arial`;
            pacmanCtx.textAlign = 'center';
            pacmanCtx.textBaseline = 'middle';
            pacmanCtx.fillText(powerUp.emoji, powerUp.x, powerUp.y);
            
            pacmanCtx.restore();
        });
    }
    
    function checkCollisions() {
        // FOX MODE: Check if ANY player fox caught the chicken
        if (playerCharacter === 'fox' && ghosts.length > 0 && pacmanGameRunning) {
            // Check spawn protection - don't detect collision immediately after spawn
            if (Date.now() < spawnProtectionTime) {
                return; // Skip all collision detection during spawn protection
            }
            
            // Make sure chicken position exists
            if (!pacmanPosition) {
                return;
            }
            
            // Check collision with ANY player fox
            let chickenCaught = false;
            let catchingFox = null;
            
            ghosts.forEach(ghost => {
                if (ghost.isPlayer && !chickenCaught) {
                    const distance = Math.sqrt(
                        Math.pow(pacmanPosition.x - ghost.x, 2) + 
                        Math.pow(pacmanPosition.y - ghost.y, 2)
                    );
                    
                    const actualFoxSize = ghost.size || ghostSize;
                    const catchDistance = (pacmanSize + actualFoxSize/2) * 0.7; // 70% of normal collision
                    
                    if (distance < catchDistance) {
                        chickenCaught = true;
                        catchingFox = ghost;
                    }
                }
            });
            
            if (chickenCaught && catchingFox) {
                console.log('COLLISION! Fox caught chicken! Fox pos:', catchingFox.x, catchingFox.y, 'Chicken pos:', pacmanPosition.x, pacmanPosition.y);
                
                // STOP THE GAME IMMEDIATELY
                pacmanGameRunning = false;
                
                // Fox caught the chicken! Level complete!
                const timeBonus = gameTimeRemaining * 10; // Bonus for speed
                pacmanScore += 1000 + timeBonus;
                pacmanScoreSpan.textContent = pacmanScore;
                
                // Show victory message
                pacmanStartButton.textContent = `Chicken Caught! +${1000 + timeBonus} points! Next Level`;
                pacmanStartButton.style.display = 'block';
                
                // Advance to next level
                currentLevel++;
                pacmanLevelSpan.textContent = currentLevel;
                
                return;
            }
        }
        
        // CHICKEN MODE ONLY - Check for pellet and power-up collisions
        if (playerCharacter === 'chicken') {
            // Check for pellet collisions
            for (let i = pellets.length - 1; i >= 0; i--) {
            const pellet = pellets[i];
            const distance = Math.sqrt(
                Math.pow(pacmanPosition.x - pellet.x, 2) + 
                Math.pow(pacmanPosition.y - pellet.y, 2)
            );
            
            if (distance < pacmanSize) {
                pellets.splice(i, 1);
                pacmanScore += 10;
                pacmanScoreSpan.textContent = pacmanScore;
                // Chicken ate corn
            }
        }
        
        // Check for life pellet collisions
        for (let i = lifePellets.length - 1; i >= 0; i--) {
            const pellet = lifePellets[i];
            const distance = Math.sqrt(
                Math.pow(pacmanPosition.x - pellet.x, 2) + 
                Math.pow(pacmanPosition.y - pellet.y, 2)
            );
            
            if (distance < pacmanSize) {
                lifePellets.splice(i, 1);
                pacmanLives++;
                pacmanLivesSpan.textContent = pacmanLives;
                
                // Display a message for the extra life
                createExtraLifeMessage();
            }
        }
        
        // Check for power pellet collisions
        for (let i = powerPellets.length - 1; i >= 0; i--) {
            const pellet = powerPellets[i];
            const distance = Math.sqrt(
                Math.pow(pacmanPosition.x - pellet.x, 2) + 
                Math.pow(pacmanPosition.y - pellet.y, 2)
            );
            
            if (distance < pacmanSize) {
                powerPellets.splice(i, 1);
                pacmanScore += 50;
                pacmanScoreSpan.textContent = pacmanScore;
                
                // Enter power mode - special feed makes chicken stronger!
                powerMode = true;
                powerModeTimer = Date.now() + 4000; // 4 seconds of power (reduced from 7)
                ghostsEaten = 0;
                
                // Make all ghosts frightened
                ghosts.forEach(ghost => {
                    ghost.frightened = true;
                });
            }
        }
        
        // Check for special power-up collisions
        for (let i = specialPowerUps.length - 1; i >= 0; i--) {
            const powerUp = specialPowerUps[i];
            const distance = Math.sqrt(
                Math.pow(pacmanPosition.x - powerUp.x, 2) + 
                Math.pow(pacmanPosition.y - powerUp.y, 2)
            );
            
            if (distance < pacmanSize) {
                specialPowerUps.splice(i, 1);
                pacmanScore += 30; // Points for collecting power-up
                pacmanScoreSpan.textContent = pacmanScore;
                
                // Create visual effect to indicate power-up collection
                const effectText = document.createElement('div');
                effectText.textContent = powerUp.description + '!';
                effectText.style.position = 'absolute';
                effectText.style.left = '50%';
                effectText.style.top = '40%';
                effectText.style.transform = 'translate(-50%, -50%)';
                effectText.style.fontSize = '24px';
                effectText.style.fontWeight = 'bold';
                effectText.style.color = '#000';
                effectText.style.zIndex = '1000';
                effectText.style.transition = 'opacity 1s';
                document.body.appendChild(effectText);
                
                // Fade out and remove after a delay
                setTimeout(() => {
                    effectText.style.opacity = '0';
                    setTimeout(() => {
                        document.body.removeChild(effectText);
                    }, 1000);
                }, 1000);
                
                // Apply the power-up effect based on type
                switch(powerUp.type) {
                    case 'speed':
                        // Speed boost for 5 seconds
                        speedBoostActive = true;
                        speedBoostTimer = Date.now() + 5000;
                        console.log('Speed boost activated!');
                        break;
                        
                    case 'invincibility':
                        // Invincibility for 7 seconds
                        invincibilityActive = true;
                        invincibilityTimer = Date.now() + 7000;
                        console.log('Invincibility activated!');
                        break;
                        
                    case 'freeze':
                        // Freeze foxes for 3 seconds
                        freezeActive = true;
                        freezeTimer = Date.now() + 3000;
                        console.log('Freeze activated!');
                        break;
                }
            }
        }
        } // End of CHICKEN MODE ONLY block
        
        // Check for ghost collisions - use a safer method with a flag for ghosts to be removed
        let ghostsToRemove = [];
        
        for (let i = 0; i < ghosts.length; i++) {
            const ghost = ghosts[i];
            const distance = Math.sqrt(
                Math.pow(pacmanPosition.x - ghost.x, 2) + 
                Math.pow(pacmanPosition.y - ghost.y, 2)
            );
            
            // Use ghost's actual size if it has size boost
            const actualGhostSize = ghost.size || ghostSize;
            
            if (distance < pacmanSize + actualGhostSize/2) {
                if (powerMode && ghost.frightened) {
                    if (ghost.isBoss) {
                        // Boss takes damage instead of being eliminated immediately
                        bossHealth--;
                        
                        // Create damage visual effect
                        createEliminationEffect(ghost.x + (Math.random() * 30 - 15), ghost.y + (Math.random() * 30 - 15));
                        
                        // Add points for damaging the boss
                        pacmanScore += 300;
                        pacmanScoreSpan.textContent = pacmanScore;
                        
                        // Show damage text
                        const bossHitText = document.createElement('div');
                        bossHitText.textContent = 'BOSS DAMAGED!';
                        bossHitText.style.position = 'absolute';
                        bossHitText.style.left = `${ghost.x}px`;
                        bossHitText.style.top = `${ghost.y - 50}px`;
                        bossHitText.style.fontSize = '18px';
                        bossHitText.style.fontWeight = 'bold';
                        bossHitText.style.color = 'red';
                        bossHitText.style.zIndex = '1000';
                        bossHitText.style.transform = 'translate(-50%, -50%)';
                        bossHitText.style.transition = 'all 0.5s';
                        document.body.appendChild(bossHitText);
                        
                        // Animate and remove text
                        setTimeout(() => {
                            bossHitText.style.opacity = '0';
                            bossHitText.style.top = `${ghost.y - 80}px`;
                            setTimeout(() => {
                                document.body.removeChild(bossHitText);
                            }, 500);
                        }, 500);
                        
                        // Check if boss is defeated
                        if (bossHealth <= 0) {
                            // Boss defeated - big points and rewards!
                            pacmanScore += 2000 * currentLevel; // Big reward for defeating boss
                            pacmanScoreSpan.textContent = pacmanScore;
                            
                            // Create big explosion effect
                            for (let j = 0; j < 3; j++) {
                                setTimeout(() => {
                                    createEliminationEffect(ghost.x, ghost.y);
                                }, j * 200);
                            }
                            
                            // Mark boss for removal
                            ghostsToRemove.push(i);
                            bossActive = false;
                            
                            // Spawn multiple rewards
                            // 1. Extra life
                            lifePellets.push({
                                x: ghost.x,
                                y: ghost.y - 30,
                                pulseOffset: 0,
                                pulseDirection: 1
                            });
                            
                            // 2. Random power-ups
                            const powerUpTypes = [
                                { type: 'speed', emoji: '‚ö°', color: 'rgba(255, 255, 0, 0.8)', description: 'Speed Boost' },
                                { type: 'invincibility', emoji: 'üõ°Ô∏è', color: 'rgba(0, 100, 255, 0.8)', description: 'Shield' },
                                { type: 'freeze', emoji: '‚ùÑÔ∏è', color: 'rgba(0, 255, 255, 0.8)', description: 'Freeze' }
                            ];
                            
                            // Spawn all three types of power-ups
                            for (let j = 0; j < powerUpTypes.length; j++) {
                                const angle = (j / powerUpTypes.length) * Math.PI * 2;
                                const distance = 60;
                                const x = ghost.x + Math.cos(angle) * distance;
                                const y = ghost.y + Math.sin(angle) * distance;
                                
                                specialPowerUps.push({
                                    x: x,
                                    y: y,
                                    type: powerUpTypes[j].type,
                                    emoji: powerUpTypes[j].emoji,
                                    color: powerUpTypes[j].color,
                                    description: powerUpTypes[j].description,
                                    pulseOffset: 0,
                                    pulseDirection: 1
                                });
                            }
                            
                            // Show boss defeated message
                            const bossDefeatedText = document.createElement('div');
                            bossDefeatedText.textContent = '‚ú® BOSS DEFEATED! ‚ú®';
                            bossDefeatedText.style.position = 'absolute';
                            bossDefeatedText.style.left = '50%';
                            bossDefeatedText.style.top = '40%';
                            bossDefeatedText.style.transform = 'translate(-50%, -50%) scale(0.5)';
                            bossDefeatedText.style.fontSize = '36px';
                            bossDefeatedText.style.fontWeight = 'bold';
                            bossDefeatedText.style.color = 'gold';
                            bossDefeatedText.style.textShadow = '0 0 10px red';
                            bossDefeatedText.style.zIndex = '1000';
                            bossDefeatedText.style.transition = 'all 1s';
                            document.body.appendChild(bossDefeatedText);
                            
                            // Animate message
                            setTimeout(() => {
                                bossDefeatedText.style.transform = 'translate(-50%, -50%) scale(1.2)';
                                setTimeout(() => {
                                    bossDefeatedText.style.transform = 'translate(-50%, -50%) scale(1)';
                                    setTimeout(() => {
                                        bossDefeatedText.style.opacity = '0';
                                        setTimeout(() => {
                                            document.body.removeChild(bossDefeatedText);
                                        }, 1000);
                                    }, 2000);
                                }, 200);
                            }, 100);
                        } else {
                            // Boss not defeated yet, just knocked back slightly
                            const knockbackDistance = 50;
                            const angle = Math.atan2(ghost.y - pacmanPosition.y, ghost.x - pacmanPosition.x);
                            ghost.x += Math.cos(angle) * knockbackDistance;
                            ghost.y += Math.sin(angle) * knockbackDistance;
                            
                            // Make sure boss doesn't go through walls after knockback
                            const cellX = Math.floor(ghost.x / cellSize);
                            const cellY = Math.floor(ghost.y / cellSize);
                            if (cellX >= 0 && cellX < maze[0].length && cellY >= 0 && cellY < maze.length) {
                                if (maze[cellY][cellX] === 1) {
                                    // Move boss back if it would go through a wall
                                    ghost.x -= Math.cos(angle) * knockbackDistance;
                                    ghost.y -= Math.sin(angle) * knockbackDistance;
                                }
                            }
                            
                            // Boss temporarily becomes more frightened after being hit
                            ghost.frightened = true;
                            
                            // Boss special ability cooldown is extended when damaged
                            ghost.specialAbilityTimer = Date.now() + 2000;
                        }
                    } else {
                        // Regular ghost elimination
                        ghostsEaten++;
                        pacmanScore += ghostsEaten * 200; // 200, 400, 800, 1600 points
                        pacmanScoreSpan.textContent = pacmanScore;
                        
                        // Create a visual elimination effect at the ghost's position
                        createEliminationEffect(ghost.x, ghost.y);
                        
                        // Mark this ghost for removal
                        ghostsToRemove.push(i);
                        
                        // When a fox is eliminated:
                        // 40% chance to spawn a life pellet
                        // 20% chance to spawn a special power-up
                        // 40% chance to spawn nothing
                        const dropRoll = Math.random();
                        if (dropRoll < 0.4) {
                            // Spawn life pellet
                            lifePellets.push({
                                x: ghost.x,
                                y: ghost.y,
                                pulseOffset: 0,
                                pulseDirection: 1
                            });
                        } else if (dropRoll < 0.6) {
                            // Spawn a random special power-up
                            const powerUpTypes = [
                                { type: 'speed', emoji: '‚ö°', color: 'rgba(255, 255, 0, 0.8)', description: 'Speed Boost' },
                                { type: 'invincibility', emoji: 'üõ°Ô∏è', color: 'rgba(0, 100, 255, 0.8)', description: 'Shield' },
                                { type: 'freeze', emoji: '‚ùÑÔ∏è', color: 'rgba(0, 255, 255, 0.8)', description: 'Freeze' }
                            ];
                            const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                            
                            specialPowerUps.push({
                                x: ghost.x,
                                y: ghost.y,
                                type: randomType.type,
                                emoji: randomType.emoji,
                                color: randomType.color,
                                description: randomType.description,
                                pulseOffset: 0,
                                pulseDirection: 1
                            });
                        }
                    }
                } else if (!powerMode && !invincibilityActive && playerCharacter === 'chicken') {
                    // Chicken player gets caught if not invincible
                    pacmanLives--;
                    pacmanLivesSpan.textContent = pacmanLives;
                    
                    if (pacmanLives <= 0) {
                        // Game over
                        pacmanGameRunning = false;
                        pacmanStartButton.style.display = 'block';
                        const levelsCompleted = currentLevel - 1;
                        pacmanStartButton.textContent = `Game Over! Score: ${pacmanScore} - Levels Completed: ${levelsCompleted}`;
                    } else {
                        // Reset position
                        pacmanPosition = { x: 400, y: 300 };
                        pacmanDirection = { x: 0, y: 0 };
                    }
                }
            }
        }
        
        // Remove ghosts marked for elimination (in reverse order to avoid index issues)
        for (let i = ghostsToRemove.length - 1; i >= 0; i--) {
            const ghostIndex = ghostsToRemove[i];
            const ghostToRemove = ghosts[ghostIndex];
            
            // Clean up GIF element if it exists
            if (ghostToRemove && ghostToRemove.gifElement) {
                ghostToRemove.gifElement.remove();
                ghostToRemove.gifElement = null;
            }
            
            ghosts.splice(ghostIndex, 1);
        }
        
        // CHICKEN MODE ONLY - Check if all pellets are eaten to advance level
        if (playerCharacter === 'chicken' && pellets.length === 0 && powerPellets.length === 0) {
            pacmanScore += 1000; // Level completion bonus
            pacmanScoreSpan.textContent = pacmanScore;
            
            // Advance to next level
            currentLevel++;
            console.log("Level complete - advancing to level:", currentLevel);
            allGhostsEliminated = false;
            
            // Reset power-up states before next level
            speedBoostActive = false;
            invincibilityActive = false;
            freezeActive = false;
            
            // Reset the game with more difficult ghosts, but keep the score and lives
            initPacmanGame(false); // false means don't reset score and lives
            ghosts.forEach(ghost => {
                ghost.speed += 0.2 * currentLevel; // Make ghosts faster with each level
            });
        }
        
        // Update power mode timer
        if (powerMode && Date.now() > powerModeTimer) {
            powerMode = false;
            ghosts.forEach(ghost => {
                ghost.frightened = false;
            });
        }
    }
    
    function spawnFoxPowerUp() {
        // Don't spawn too many at once
        if (foxPowerUps.length >= 3) return;
        
        // Find a random valid path location
        const validPaths = [];
        for (let y = 1; y < maze.length - 1; y++) {
            for (let x = 1; x < maze[y].length - 1; x++) {
                if (maze[y][x] === 0) {
                    // Avoid spawning too close to player
                    const distToPlayer = Math.sqrt(
                        Math.pow(x * cellSize + cellSize / 2 - pacmanPosition.x, 2) + 
                        Math.pow(y * cellSize + cellSize / 2 - pacmanPosition.y, 2)
                    );
                    if (distToPlayer > 100) {
                        validPaths.push({ x, y });
                    }
                }
            }
        }
        
        if (validPaths.length === 0) return;
        
        const pos = validPaths[Math.floor(Math.random() * validPaths.length)];
        
        // Power-up types for foxes - STRONGER versions
        const types = [
            { type: 'speed', emoji: 'üî•', duration: 15000 },     // Increased from 8s to 15s
            { type: 'size', emoji: 'üí™', duration: 18000 },       // Increased from 10s to 18s
            { type: 'teleport', emoji: '‚ö°', duration: 0 },       // instant effect
            { type: 'clone', emoji: 'üë•', duration: 0 },          // NEW: spawns a clone
            { type: 'rage', emoji: 'üòà', duration: 12000 }        // NEW: speed + size combo
        ];
        
        const powerUpType = types[Math.floor(Math.random() * types.length)];
        
        foxPowerUps.push({
            x: pos.x * cellSize + cellSize / 2,
            y: pos.y * cellSize + cellSize / 2,
            type: powerUpType.type,
            emoji: powerUpType.emoji,
            duration: powerUpType.duration
        });
    }
    
    function checkFoxPowerUpCollisions() {
        // Check each fox against fox power-ups
        for (let i = foxPowerUps.length - 1; i >= 0; i--) {
            const powerUp = foxPowerUps[i];
            
            for (let ghost of ghosts) {
                const distance = Math.sqrt(
                    Math.pow(ghost.x - powerUp.x, 2) + 
                    Math.pow(ghost.y - powerUp.y, 2)
                );
                
                if (distance < ghostSize + 10) {
                    // Fox collected the power-up!
                    foxPowerUps.splice(i, 1);
                    
                    // Apply power-up effect
                    switch(powerUp.type) {
                        case 'speed':
                            ghost.speedBoost = true;
                            ghost.speedBoostEnd = Date.now() + powerUp.duration;
                            ghost.originalSpeed = ghost.speed;
                            ghost.speed *= 2.5; // Increased from 1.8x to 2.5x (150% faster!)
                            break;
                            
                        case 'size':
                            ghost.sizeBoost = true;
                            ghost.sizeBoostEnd = Date.now() + powerUp.duration;
                            ghost.originalSize = ghost.size || ghostSize;
                            ghost.size = (ghost.size || ghostSize) * 2.0; // Increased from 1.5x to 2.0x
                            break;
                            
                        case 'teleport':
                            // Teleport fox VERY close to player (more threatening)
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 30 + Math.random() * 30; // Reduced from 60-100 to 30-60
                            const newX = pacmanPosition.x + Math.cos(angle) * distance;
                            const newY = pacmanPosition.y + Math.sin(angle) * distance;
                            
                            // Check if teleport location is valid
                            const cellX = Math.floor(newX / cellSize);
                            const cellY = Math.floor(newY / cellSize);
                            
                            if (cellX > 0 && cellX < maze[0].length && cellY > 0 && cellY < maze.length) {
                                if (maze[cellY][cellX] === 0 || (ghost.isGhost && ghostWalls[cellY][cellX] === 1)) {
                                    ghost.x = newX;
                                    ghost.y = newY;
                                    
                                    // Visual effect for teleport
                                    createEliminationEffect(ghost.x, ghost.y);
                                }
                            }
                            break;
                            
                        case 'clone':
                            // Spawn a clone of this fox nearby
                            const cloneAngle = Math.random() * Math.PI * 2;
                            const cloneDistance = 40 + Math.random() * 40;
                            const cloneX = ghost.x + Math.cos(cloneAngle) * cloneDistance;
                            const cloneY = ghost.y + Math.sin(cloneAngle) * cloneDistance;
                            
                            const cloneCellX = Math.floor(cloneX / cellSize);
                            const cloneCellY = Math.floor(cloneY / cellSize);
                            
                            if (cloneCellX > 0 && cloneCellX < maze[0].length && 
                                cloneCellY > 0 && cloneCellY < maze.length &&
                                maze[cloneCellY][cloneCellX] === 0) {
                                
                                const clone = {
                                    x: cloneX,
                                    y: cloneY,
                                    color: ghost.color,
                                    direction: { x: 0, y: 0 },
                                    speed: ghost.speed,
                                    frightened: false,
                                    isGhost: ghost.isGhost,
                                    isClone: true // Mark as clone
                                };
                                
                                ghosts.push(clone);
                                createEliminationEffect(cloneX, cloneY);
                            }
                            break;
                            
                        case 'rage':
                            // RAGE MODE: Both speed AND size boost together!
                            ghost.rageMode = true;
                            ghost.rageModeEnd = Date.now() + powerUp.duration;
                            
                            if (!ghost.speedBoost) {
                                ghost.originalSpeed = ghost.speed;
                                ghost.speed *= 2.2; // 120% faster
                            }
                            
                            if (!ghost.sizeBoost) {
                                ghost.originalSize = ghost.size || ghostSize;
                                ghost.size = (ghost.size || ghostSize) * 1.8;
                            }
                            break;
                    }
                    
                    // Create visual effect at collection point
                    createEliminationEffect(powerUp.x, powerUp.y);
                    break; // Power-up consumed, move to next power-up
                }
            }
        }
    }
    
    function moveGhosts() {
        // Handle boss special abilities
        if (bossActive && bossFox) {
            // Update boss attack cooldown
            if (bossFox.attackCooldown > 0) {
                bossFox.attackCooldown--;
                bossFox.attackRadius += 5;
                
                // Check if player is within attack range
                const distanceToBoss = Math.sqrt(
                    Math.pow(pacmanPosition.x - bossFox.x, 2) + 
                    Math.pow(pacmanPosition.y - bossFox.y, 2)
                );
                
                if (distanceToBoss < bossFox.attackRadius && !invincibilityActive) {
                    // Player gets hit by boss attack
                    pacmanLives--;
                    pacmanLivesSpan.textContent = pacmanLives;
                    
                    // Create attack hit effect
                    createEliminationEffect(pacmanPosition.x, pacmanPosition.y);
                    
                    // Reset boss attack
                    bossFox.attackCooldown = 0;
                    bossFox.attackRadius = 0;
                    
                    // Check for game over
                    if (pacmanLives <= 0) {
                        pacmanGameRunning = false;
                        pacmanStartButton.style.display = 'block';
                        const levelsCompleted = currentLevel - 1;
                        pacmanStartButton.textContent = `Game Over! Score: ${pacmanScore} - Levels Completed: ${levelsCompleted}`;
                    } else {
                        // Temporarily move player to safe position
                        pacmanPosition = { x: 400, y: 300 };
                        pacmanDirection = { x: 0, y: 0 };
                    }
                }
            }
            
            // Boss special abilities based on remaining health
            if (!bossFox.frightened && Date.now() > bossFox.specialAbilityTimer) {
                // Special abilities more frequent when boss has less health
                const healthPercentage = bossHealth / bossMaxHealth;
                
                if (Math.random() < 0.02 + (0.08 * (1 - healthPercentage))) {
                    const ability = Math.floor(Math.random() * 3);
                    
                    switch(ability) {
                        case 0: // Area attack
                            bossFox.attackCooldown = 20;
                            bossFox.attackRadius = 20;
                            bossFox.specialAbilityTimer = Date.now() + 5000;
                            console.log("Boss used area attack!");
                            break;
                            
                        case 1: // Dash toward player
                            // Store target position
                            bossFox.dashTarget = {
                                x: pacmanPosition.x,
                                y: pacmanPosition.y
                            };
                            bossFox.dashCooldown = 30;
                            bossFox.specialAbilityTimer = Date.now() + 4000;
                            console.log("Boss used dash attack!");
                            break;
                            
                        case 2: // Summon minion
                            // Only summon if there are fewer than 8 ghosts
                            if (ghosts.length < 8) {
                                const offset = 40;
                                const ghostColors = ['red', 'pink', 'cyan', 'orange'];
                                const newGhost = {
                                    x: bossFox.x + (Math.random() * offset - offset/2),
                                    y: bossFox.y + (Math.random() * offset - offset/2),
                                    color: ghostColors[Math.floor(Math.random() * ghostColors.length)],
                                    direction: { x: 0, y: 0 },
                                    speed: 1.5,
                                    frightened: false
                                };
                                
                                ghosts.push(newGhost);
                                
                                // Create summon effect
                                createEliminationEffect(newGhost.x, newGhost.y);
                                console.log("Boss summoned a minion!");
                            }
                            bossFox.specialAbilityTimer = Date.now() + 8000;
                            break;
                    }
                }
            }
            
            // Process boss dash attack
            if (bossFox.dashCooldown > 0) {
                bossFox.dashCooldown--;
                
                // Move toward dash target
                if (bossFox.dashTarget) {
                    const angle = Math.atan2(
                        bossFox.dashTarget.y - bossFox.y,
                        bossFox.dashTarget.x - bossFox.x
                    );
                    
                    const dashSpeed = 5;
                    const newX = bossFox.x + Math.cos(angle) * dashSpeed;
                    const newY = bossFox.y + Math.sin(angle) * dashSpeed;
                    
                    // Check for wall collision
                    const cellX = Math.floor(newX / cellSize);
                    const cellY = Math.floor(newY / cellSize);
                    
                    if (cellX >= 0 && cellX < maze[0].length && 
                        cellY >= 0 && cellY < maze.length && 
                        maze[cellY][cellX] !== 1) {
                        bossFox.x = newX;
                        bossFox.y = newY;
                    } else {
                        // Hit a wall, end dash early
                        bossFox.dashCooldown = 0;
                        bossFox.dashTarget = null;
                    }
                    
                    // Create trail effect
                    if (bossFox.dashCooldown % 3 === 0) {
                        eliminationEffects.push({
                            x: bossFox.x,
                            y: bossFox.y,
                            radius: 5,
                            color: 'rgba(255, 165, 0, 0.7)',
                            speedX: 0,
                            speedY: 0,
                            life: 10,
                            currentLife: 0,
                            text: null,
                            isScoreText: false
                        });
                    }
                }
            }
        }
        
        // Check if freeze power-up is active
        if (freezeActive) {
            // Draw frozen effect on all ghosts but don't move them
            ghosts.forEach(ghost => {
                // Add a simpler frozen visual effect
                pacmanCtx.save();
                
                // Light blue tint around the ghost
                pacmanCtx.beginPath();
                pacmanCtx.arc(ghost.x, ghost.y, ghostSize * 1.2, 0, Math.PI * 2);
                pacmanCtx.fillStyle = 'rgba(200, 240, 255, 0.2)';
                pacmanCtx.fill();
                pacmanCtx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
                pacmanCtx.lineWidth = 1;
                pacmanCtx.stroke();
                
                // Single snowflake above the ghost
                pacmanCtx.font = "15px Arial";
                pacmanCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                pacmanCtx.fillText('‚ùÑ', ghost.x, ghost.y - ghostSize * 1.2);
                
                pacmanCtx.restore();
            });
            
            // Check if freeze effect has expired
            if (Date.now() > freezeTimer) {
                freezeActive = false;
            }
            
            return; // Skip ghost movement while frozen
        }
        
        ghosts.forEach((ghost, index) => {
            // Move ALL player-controlled foxes together (fox pack mode)
            if (playerCharacter === 'fox' && ghost.isPlayer) {
                // Move the player fox based on their direction with wall collision detection
                const speed = ghost.frightened ? ghost.speed * 0.6 : ghost.speed;
                
                // Calculate potential new position
                const newX = ghost.x + ghost.direction.x * speed;
                const newY = ghost.y + ghost.direction.y * speed;
                
                // Check if new position would collide with a wall
                const cellX = Math.floor(newX / cellSize);
                const cellY = Math.floor(newY / cellSize);
                
                // Only move if the new position is valid (not a wall)
                if (cellX >= 0 && cellX < maze[0].length && 
                    cellY >= 0 && cellY < maze.length && 
                    maze[cellY][cellX] === 0) {
                    ghost.x = newX;
                    ghost.y = newY;
                }
                
                // Smooth centering for player fox
                const centerXPos = Math.floor(ghost.x / cellSize) * cellSize + cellSize / 2;
                const centerYPos = Math.floor(ghost.y / cellSize) * cellSize + cellSize / 2;
                
                if (ghost.direction.x !== 0 && Math.abs(ghost.y - centerYPos) > 2) {
                    const correction = Math.min(1, Math.abs(ghost.y - centerYPos) / 4);
                    ghost.y += (centerYPos > ghost.y ? correction : -correction);
                }
                if (ghost.direction.y !== 0 && Math.abs(ghost.x - centerXPos) > 2) {
                    const correction = Math.min(1, Math.abs(ghost.x - centerXPos) / 4);
                    ghost.x += (centerXPos > ghost.x ? correction : -correction);
                }
                
                return; // Skip the rest of AI logic for player foxes
            }
            
            const currentCellX = Math.floor(ghost.x / cellSize);
            const currentCellY = Math.floor(ghost.y / cellSize);
            
            // Initialize lastCell if not set
            if (!ghost.lastCell) {
                ghost.lastCell = { x: currentCellX, y: currentCellY };
            }
            
            // Check if ghost is well-centered in current cell
            const centerX = currentCellX * cellSize + cellSize / 2;
            const centerY = currentCellY * cellSize + cellSize / 2;
            const isWellCentered = Math.abs(ghost.x - centerX) < 3 && Math.abs(ghost.y - centerY) < 3;
            
            // Check if ghost has no direction (just spawned)
            const hasNoDirection = ghost.direction.x === 0 && ghost.direction.y === 0;
            
            // Only recalculate direction at intersections (when entering a new cell and well-centered) or if no direction
            const hasChangedCell = currentCellX !== ghost.lastCell.x || currentCellY !== ghost.lastCell.y;
            
            if ((hasChangedCell && isWellCentered) || hasNoDirection) {
                ghost.lastCell = { x: currentCellX, y: currentCellY };
                
                // Determine potential directions
                const possibleDirections = [];
                
                // Check each direction
                const directions = [
                    { x: 0, y: -1 }, // Up
                    { x: 1, y: 0 },  // Right
                    { x: 0, y: 1 },  // Down
                    { x: -1, y: 0 }  // Left
                ];
                
                directions.forEach(dir => {
                    const newX = currentCellX + dir.x;
                    const newY = currentCellY + dir.y;
                    
                    // Ghost foxes can pass through certain walls
                    if (ghost.isGhost) {
                        // Ghost foxes can pass through walls marked as ghost-passable (ghostWalls[y][x] === 1)
                        if (newX >= 0 && newX < maze[0].length && 
                            newY >= 0 && newY < maze.length) {
                            
                            // Allow movement if it's a path OR a ghost-passable wall
                            const canPass = maze[newY][newX] === 0 || (ghostWalls[newY][newX] === 1);
                            
                            if (canPass) {
                                // Avoid reversing direction unless it's the only option
                                if (ghost.direction.x !== -dir.x || ghost.direction.y !== -dir.y || possibleDirections.length === 0) {
                                    possibleDirections.push(dir);
                                }
                            }
                        }
                    } else {
                        // Regular foxes must stay on paths
                        if (newX >= 0 && newX < maze[0].length && 
                            newY >= 0 && newY < maze.length && 
                            maze[newY][newX] === 0) {
                            
                            // Avoid reversing direction unless it's the only option
                            if (ghost.direction.x !== -dir.x || ghost.direction.y !== -dir.y || possibleDirections.length === 0) {
                                possibleDirections.push(dir);
                            }
                        }
                    }
                });
                
                // Choose direction based on mode
                if (possibleDirections.length > 0) {
                    let chosenDirection;
                    
                    if (powerMode && ghost.frightened) {
                        // When frightened, choose a random direction away from player
                        possibleDirections.sort((a, b) => {
                            const distA = Math.pow(pacmanPosition.x - (ghost.x + a.x * cellSize), 2) + 
                                         Math.pow(pacmanPosition.y - (ghost.y + a.y * cellSize), 2);
                            const distB = Math.pow(pacmanPosition.x - (ghost.x + b.x * cellSize), 2) + 
                                         Math.pow(pacmanPosition.y - (ghost.y + b.y * cellSize), 2);
                            return distB - distA; // Sort by farthest from Pac-Man
                        });
                        // Pick one of the top directions to flee
                        const topChoices = possibleDirections.slice(0, Math.max(2, Math.ceil(possibleDirections.length / 2)));
                        chosenDirection = topChoices[Math.floor(Math.random() * topChoices.length)];
                    } else if (ghost.isBoss && !ghost.dashCooldown) {
                        // Boss fox has more advanced AI when not dashing
                        
                        // When chasing, prefer directions that get closer to Pac-Man
                        possibleDirections.sort((a, b) => {
                            const distA = Math.pow(pacmanPosition.x - (ghost.x + a.x * cellSize), 2) + 
                                         Math.pow(pacmanPosition.y - (ghost.y + a.y * cellSize), 2);
                            const distB = Math.pow(pacmanPosition.x - (ghost.x + b.x * cellSize), 2) + 
                                         Math.pow(pacmanPosition.y - (ghost.y + b.y * cellSize), 2);
                            return distA - distB; // Sort by closest to Pac-Man
                        });
                        
                        // Boss is much more determined to chase the player - less randomness
                        if (Math.random() < 0.05) { // Only 5% chance to choose randomly
                            chosenDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                        } else {
                            chosenDirection = possibleDirections[0]; // Choose closest direction to Pac-Man
                        }
                        
                        // Boss will occasionally perform a predictive movement - anticipating player's move
                        if (Math.random() < 0.3) {
                            // Try to predict where player is going based on their direction
                            const predictedPosition = {
                                x: pacmanPosition.x + (pacmanDirection.x * 100),
                                y: pacmanPosition.y + (pacmanDirection.y * 100)
                            };
                            
                            // Sort directions based on predicted position
                            possibleDirections.sort((a, b) => {
                                const predDistA = Math.pow(predictedPosition.x - (ghost.x + a.x * cellSize), 2) + 
                                               Math.pow(predictedPosition.y - (ghost.y + a.y * cellSize), 2);
                                const predDistB = Math.pow(predictedPosition.x - (ghost.x + b.x * cellSize), 2) + 
                                               Math.pow(predictedPosition.y - (ghost.y + b.y * cellSize), 2);
                                return predDistA - predDistB;
                            });
                            
                            chosenDirection = possibleDirections[0];
                        }
                    } else {
                        // Regular fox behavior - smarter chasing with less randomness
                        // When chasing, prefer directions that get closer to Pac-Man
                        possibleDirections.sort((a, b) => {
                            const distA = Math.pow(pacmanPosition.x - (ghost.x + a.x * cellSize), 2) + 
                                         Math.pow(pacmanPosition.y - (ghost.y + a.y * cellSize), 2);
                            const distB = Math.pow(pacmanPosition.x - (ghost.x + b.x * cellSize), 2) + 
                                         Math.pow(pacmanPosition.y - (ghost.y + b.y * cellSize), 2);
                            return distA - distB; // Sort by closest to Pac-Man
                        });
                        
                        // Reduced randomness - only 10% chance to not chase optimally
                        if (Math.random() < 0.1) { // 10% chance to choose randomly (reduced from 20%)
                            chosenDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                        } else {
                            chosenDirection = possibleDirections[0]; // Choose closest direction to Pac-Man
                        }
                    }
                    
                    ghost.direction = chosenDirection;
                }
            }
            
            // Move the ghost smoothly
            const speed = ghost.frightened ? ghost.speed * 0.6 : ghost.speed; // Slower when frightened
            ghost.x += ghost.direction.x * speed;
            ghost.y += ghost.direction.y * speed;
            
            // Smooth centering - only apply when moving perpendicular to the offset
            const centerXPos = Math.floor(ghost.x / cellSize) * cellSize + cellSize / 2;
            const centerYPos = Math.floor(ghost.y / cellSize) * cellSize + cellSize / 2;
            
            // Center vertically when moving horizontally
            if (ghost.direction.x !== 0 && Math.abs(ghost.y - centerYPos) > 2) {
                const correction = Math.min(1, Math.abs(ghost.y - centerYPos) / 4);
                ghost.y += (centerYPos > ghost.y ? correction : -correction);
            }
            // Center horizontally when moving vertically
            if (ghost.direction.y !== 0 && Math.abs(ghost.x - centerXPos) > 2) {
                const correction = Math.min(1, Math.abs(ghost.x - centerXPos) / 4);
                ghost.x += (centerXPos > ghost.x ? correction : -correction);
            }
            
            // Check and remove expired power-ups
            const currentTime = Date.now();
            
            if (ghost.speedBoost && currentTime > ghost.speedBoostEnd) {
                ghost.speedBoost = false;
                ghost.speed = ghost.originalSpeed;
                delete ghost.originalSpeed;
                delete ghost.speedBoostEnd;
            }
            
            if (ghost.sizeBoost && currentTime > ghost.sizeBoostEnd) {
                ghost.sizeBoost = false;
                ghost.size = ghost.originalSize;
                delete ghost.originalSize;
                delete ghost.sizeBoostEnd;
            }
            
            if (ghost.rageMode && currentTime > ghost.rageModeEnd) {
                ghost.rageMode = false;
                // Reset speed and size if not boosted by other power-ups
                if (!ghost.speedBoost && ghost.originalSpeed) {
                    ghost.speed = ghost.originalSpeed;
                    delete ghost.originalSpeed;
                }
                if (!ghost.sizeBoost && ghost.originalSize) {
                    ghost.size = ghost.originalSize;
                    delete ghost.originalSize;
                }
                delete ghost.rageModeEnd;
            }
        });
    }
    
    function moveAIChicken() {
        // AI chicken behavior when player is a fox
        
        // Safety check - make sure player fox exists
        if (!ghosts || ghosts.length === 0) {
            // No fox yet, just move randomly
            if (pacmanDirection.x === 0 && pacmanDirection.y === 0) {
                // Pick a random direction to start
                const dirs = [{ x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 0 }];
                pacmanDirection = dirs[Math.floor(Math.random() * dirs.length)];
            }
        }
        
        const currentCellX = Math.floor(pacmanPosition.x / cellSize);
        const currentCellY = Math.floor(pacmanPosition.y / cellSize);
        
        // Initialize lastCell for chicken if not set
        if (!pacmanPosition.lastCell) {
            pacmanPosition.lastCell = { x: currentCellX, y: currentCellY };
        }
        
        // Check if centered in current cell
        const centerX = currentCellX * cellSize + cellSize / 2;
        const centerY = currentCellY * cellSize + cellSize / 2;
        const isWellCentered = Math.abs(pacmanPosition.x - centerX) < 3 && Math.abs(pacmanPosition.y - centerY) < 3;
        
        // Check if chicken has no direction or entered new cell
        const hasNoDirection = pacmanDirection.x === 0 && pacmanDirection.y === 0;
        const hasChangedCell = currentCellX !== pacmanPosition.lastCell.x || currentCellY !== pacmanPosition.lastCell.y;
        
        if ((hasChangedCell && isWellCentered) || hasNoDirection) {
            pacmanPosition.lastCell = { x: currentCellX, y: currentCellY };
            
            // Get player fox position (first ghost is the player)
            const playerFox = ghosts[0];
            if (!playerFox) {
                // Fallback: move in any valid direction
                const dirs = [{ x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 0 }];
                pacmanDirection = dirs[Math.floor(Math.random() * dirs.length)];
                return;
            }
            
            // Determine possible directions
            const possibleDirections = [];
            const directions = [
                { x: 0, y: -1 }, // Up
                { x: 1, y: 0 },  // Right
                { x: 0, y: 1 },  // Down
                { x: -1, y: 0 }  // Left
            ];
            
            directions.forEach(dir => {
                const newX = currentCellX + dir.x;
                const newY = currentCellY + dir.y;
                
                if (newX >= 0 && newX < maze[0].length && 
                    newY >= 0 && newY < maze.length && 
                    maze[newY][newX] === 0) {
                    
                    // Avoid reversing direction unless necessary
                    if (pacmanDirection.x !== -dir.x || pacmanDirection.y !== -dir.y || possibleDirections.length === 0) {
                        possibleDirections.push(dir);
                    }
                }
            });
            
            if (possibleDirections.length > 0) {
                // Calculate distance to fox
                const distanceToFox = Math.sqrt(
                    Math.pow(playerFox.x - pacmanPosition.x, 2) + 
                    Math.pow(playerFox.y - pacmanPosition.y, 2)
                );
                
                // Different behavior based on distance to fox
                if (distanceToFox < 150) {
                    // FLEE MODE: Fox is close, run away!
                    possibleDirections.sort((a, b) => {
                        const nextPosA = {
                            x: pacmanPosition.x + a.x * cellSize,
                            y: pacmanPosition.y + a.y * cellSize
                        };
                        const nextPosB = {
                            x: pacmanPosition.x + b.x * cellSize,
                            y: pacmanPosition.y + b.y * cellSize
                        };
                        
                        const distA = Math.sqrt(
                            Math.pow(playerFox.x - nextPosA.x, 2) + 
                            Math.pow(playerFox.y - nextPosA.y, 2)
                        );
                        const distB = Math.sqrt(
                            Math.pow(playerFox.x - nextPosB.x, 2) + 
                            Math.pow(playerFox.y - nextPosB.y, 2)
                        );
                        
                        return distB - distA; // Sort by farthest from fox
                    });
                    
                    // Choose the direction that maximizes distance from fox
                    pacmanDirection = possibleDirections[0];
                } else {
                    // WANDER MODE: Fox is far, explore randomly but prefer continuing straight
                    const continueStraight = possibleDirections.find(dir => 
                        dir.x === pacmanDirection.x && dir.y === pacmanDirection.y
                    );
                    
                    if (continueStraight && Math.random() < 0.7) {
                        // 70% chance to continue in same direction
                        pacmanDirection = continueStraight;
                    } else {
                        // Choose a random valid direction
                        pacmanDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                    }
                }
            }
        }
        
        // Move the AI chicken
        const speedFactor = 2; // Normal speed
        const newX = pacmanPosition.x + (pacmanDirection.x * speedFactor);
        const newY = pacmanPosition.y + (pacmanDirection.y * speedFactor);
        
        const targetCellX = Math.floor(newX / cellSize);
        const targetCellY = Math.floor(newY / cellSize);
        
        if (targetCellX >= 0 && targetCellX < maze[0].length && 
            targetCellY >= 0 && targetCellY < maze.length && 
            maze[targetCellY][targetCellX] === 0) {
            pacmanPosition.x = newX;
            pacmanPosition.y = newY;
        }
        
        // Smooth centering for AI chicken
        const centerXPos = Math.floor(pacmanPosition.x / cellSize) * cellSize + cellSize / 2;
        const centerYPos = Math.floor(pacmanPosition.y / cellSize) * cellSize + cellSize / 2;
        
        if (pacmanDirection.x !== 0 && Math.abs(pacmanPosition.y - centerYPos) > 2) {
            const correction = Math.min(1, Math.abs(pacmanPosition.y - centerYPos) / 4);
            pacmanPosition.y += (centerYPos > pacmanPosition.y ? correction : -correction);
        }
        if (pacmanDirection.y !== 0 && Math.abs(pacmanPosition.x - centerXPos) > 2) {
            const correction = Math.min(1, Math.abs(pacmanPosition.x - centerXPos) / 4);
            pacmanPosition.x += (centerXPos > pacmanPosition.x ? correction : -correction);
        }
    }
    
    function movePacman() {
        // Calculate speed factor based on power-ups
        const speedFactor = speedBoostActive ? 3 : 2; // 50% speed increase with boost
        
        // Check if speed boost has expired
        if (speedBoostActive && Date.now() > speedBoostTimer) {
            speedBoostActive = false;
        }
        
        // Check if invincibility has expired
        if (invincibilityActive && Date.now() > invincibilityTimer) {
            invincibilityActive = false;
        }
        
        // Check if freeze has expired
        if (freezeActive && Date.now() > freezeTimer) {
            freezeActive = false;
        }
        
        // Calculate new position with appropriate speed
        const newX = pacmanPosition.x + (pacmanDirection.x * speedFactor);
        const newY = pacmanPosition.y + (pacmanDirection.y * speedFactor);
        
        // Get current cell and target cell
        const currentCellX = Math.floor(pacmanPosition.x / cellSize);
        const currentCellY = Math.floor(pacmanPosition.y / cellSize);
        const targetCellX = Math.floor(newX / cellSize);
        const targetCellY = Math.floor(newY / cellSize);
        
        // Check for wall collision
        if (targetCellX >= 0 && targetCellX < maze[0].length && 
            targetCellY >= 0 && targetCellY < maze.length) {
            
            // If there's no wall in the target cell, or if we're still in the same cell
            if (maze[targetCellY][targetCellX] === 0 || 
               (currentCellX === targetCellX && currentCellY === targetCellY)) {
                pacmanPosition.x = newX;
                pacmanPosition.y = newY;
            } else {
                // If we hit a wall, try to slide along it by moving only in one direction
                if (pacmanDirection.x !== 0) {
                    // Try to move vertically to slide along a horizontal wall
                    const centerY = currentCellY * cellSize + cellSize / 2;
                    if (pacmanPosition.y < centerY && maze[currentCellY+1][currentCellX] === 0) {
                        pacmanPosition.y += 2;
                    } else if (pacmanPosition.y > centerY && maze[currentCellY-1][currentCellX] === 0) {
                        pacmanPosition.y -= 2;
                    }
                } else if (pacmanDirection.y !== 0) {
                    // Try to move horizontally to slide along a vertical wall
                    const centerX = currentCellX * cellSize + cellSize / 2;
                    if (pacmanPosition.x < centerX && maze[currentCellY][currentCellX+1] === 0) {
                        pacmanPosition.x += 2;
                    } else if (pacmanPosition.x > centerX && maze[currentCellY][currentCellX-1] === 0) {
                        pacmanPosition.x -= 2;
                    }
                }
            }
        }
        
        // Wrap around the screen if Pac-Man goes out of bounds
        if (pacmanPosition.x < 0) pacmanPosition.x = pacmanCanvas.width;
        if (pacmanPosition.x > pacmanCanvas.width) pacmanPosition.x = 0;
        if (pacmanPosition.y < 0) pacmanPosition.y = pacmanCanvas.height;
        if (pacmanPosition.y > pacmanCanvas.height) pacmanPosition.y = 0;
    }
    
    function pacmanGameLoop() {
        if (!pacmanGameRunning) return;
        
        try {
            // Update timer
            const currentTime = Date.now();
            const elapsedSeconds = Math.floor((currentTime - lastTimerUpdate) / 1000);
            
            if (elapsedSeconds >= 1) {
                gameTimeRemaining -= elapsedSeconds;
                lastTimerUpdate = currentTime;
                
                // Update timer display
                const minutes = Math.floor(gameTimeRemaining / 60);
                const seconds = gameTimeRemaining % 60;
                pacmanTimerSpan.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Change color based on time remaining
                if (gameTimeRemaining <= 30) {
                    pacmanTimerSpan.style.color = '#ff0000'; // Red for last 30 seconds
                } else if (gameTimeRemaining <= 60) {
                    pacmanTimerSpan.style.color = '#ff8800'; // Orange for last minute
                } else {
                    pacmanTimerSpan.style.color = '#ff4500'; // Default orange-red
                }
                
                // Check if time is up
                if (gameTimeRemaining <= 0) {
                    gameTimeRemaining = 0;
                    pacmanTimerSpan.textContent = '0:00';
                    pacmanGameRunning = false;
                    pacmanStartButton.style.display = 'block';
                    const levelsCompleted = currentLevel - 1; // Current level wasn't completed
                    pacmanStartButton.textContent = `Time's Up! Score: ${pacmanScore} - Levels Completed: ${levelsCompleted}`;
                    return;
                }
            }
            
            // Spawn fox power-ups more frequently (every 8-12 seconds, increased from 12-18)
            foxPowerUpSpawnTimer += (currentTime - (lastTimerUpdate - (elapsedSeconds * 1000))) / 1000;
            if (foxPowerUpSpawnTimer >= 8 + Math.random() * 4) {
                foxPowerUpSpawnTimer = 0;
                spawnFoxPowerUp();
            }
            
            pacmanCtx.clearRect(0, 0, pacmanCanvas.width, pacmanCanvas.height);
            drawMaze();
            drawPellets(); // This now includes life pellets and special power-ups
            
            // Move entities based on player character
            if (playerCharacter === 'chicken') {
                movePacman(); // Player controls chicken
                moveGhosts(); // AI controls foxes
            } else {
                moveAIChicken(); // AI controls chicken
                moveGhosts(); // Player controls first fox, AI controls others
            }
            
            checkCollisions();
            checkFoxPowerUpCollisions(); // Check if foxes collected their power-ups
            drawPacman();
            drawGhosts();
            drawMinimap(); // Draw the minimap showing ghost-passable walls
            
            // Draw any active elimination effects (on top of everything else)
            updateEliminationEffects();
            
            // Update power-up indicators in the HUD
            updatePowerUpIndicators();
        } catch (error) {
            console.error('Error in pacman game loop:', error);
        }
        
        // Function to update power-up indicators in the HUD
        function updatePowerUpIndicators() {
            // Get the indicator elements
            const speedIndicator = document.getElementById('speed-indicator');
            const shieldIndicator = document.getElementById('shield-indicator');
            const freezeIndicator = document.getElementById('freeze-indicator');
            
            // Update visibility based on active status
            if (speedBoostActive) {
                speedIndicator.style.display = 'inline';
                // Calculate and display remaining time
                const timeLeft = Math.max(0, Math.ceil((speedBoostTimer - Date.now()) / 1000));
                speedIndicator.textContent = `\u26a1 Speed (${timeLeft}s)`;
            } else {
                speedIndicator.style.display = 'none';
            }
            
            if (invincibilityActive) {
                shieldIndicator.style.display = 'inline';
                // Calculate and display remaining time
                const timeLeft = Math.max(0, Math.ceil((invincibilityTimer - Date.now()) / 1000));
                shieldIndicator.textContent = `\ud83d\udee1\ufe0f Shield (${timeLeft}s)`;
            } else {
                shieldIndicator.style.display = 'none';
            }
            
            if (freezeActive) {
                freezeIndicator.style.display = 'inline';
                // Calculate and display remaining time
                const timeLeft = Math.max(0, Math.ceil((freezeTimer - Date.now()) / 1000));
                freezeIndicator.textContent = `\u2744\ufe0f Freeze (${timeLeft}s)`;
            } else {
                freezeIndicator.style.display = 'none';
            }
        }
        
        // Check if all ghosts are eliminated
        if (ghosts.length === 0 && !allGhostsEliminated) {
            // Add bonus points for eliminating all ghosts
            pacmanScore += 500;
            pacmanScoreSpan.textContent = pacmanScore;
            allGhostsEliminated = true;
            
            // Create a "Next Level" button
            nextLevelButton = document.createElement('button');
            nextLevelButton.id = 'nextLevelButton';
            nextLevelButton.textContent = 'Advance to Next Level';
            nextLevelButton.style.position = 'absolute';
            nextLevelButton.style.top = `${pacmanCanvas.offsetTop + pacmanCanvas.height/2 - 25}px`;
            nextLevelButton.style.left = `${pacmanCanvas.offsetLeft + pacmanCanvas.width/2 - 100}px`;
            nextLevelButton.style.zIndex = '1000';
            nextLevelButton.style.padding = '10px';
            nextLevelButton.style.backgroundColor = '#4CAF50';
            nextLevelButton.style.color = 'white';
            nextLevelButton.style.border = 'none';
            nextLevelButton.style.borderRadius = '5px';
            nextLevelButton.style.cursor = 'pointer';
            nextLevelButton.style.fontSize = '16px';
            nextLevelButton.style.width = '200px';
            
            nextLevelButton.addEventListener('click', () => {
                // Increment level and initialize new game, but keep score and lives
                currentLevel++;
                allGhostsEliminated = false;
                initPacmanGame(false); // Don't reset score and lives
            });
            
            document.body.appendChild(nextLevelButton);
            
            // Show message on screen
            pacmanCtx.fillStyle = 'rgba(0,0,0,0.7)';
            pacmanCtx.fillRect(pacmanCanvas.width/2 - 200, pacmanCanvas.height/2 - 60, 400, 50);
            pacmanCtx.font = '20px Arial';
            pacmanCtx.fillStyle = 'white';
            pacmanCtx.textAlign = 'center';
            pacmanCtx.fillText('All foxes eliminated! Continue or advance?', pacmanCanvas.width/2, pacmanCanvas.height/2 - 25);
        }
        
        requestAnimationFrame(pacmanGameLoop);
    }
    
    // Load the Pac-Man GIFs
    loadPacmanChickenGif();
    loadPacmanFoxGif();
    
    pacmanStartButton.addEventListener('click', () => {
        if (!pacmanGameRunning) {
            // Check if this is continuing a game or starting fresh
            if (characterSelected && pacmanStartButton.textContent.includes('Next Level')) {
                // Continue to next level with same character
                pacmanGameRunning = true;
                pacmanStartButton.style.display = 'none';
                initPacmanGame(false); // false = don't reset score/lives, just continue
                pacmanGameLoop();
            } else {
                // Show character selection screen for new game
                characterSelected = false;
                const characterSelection = document.getElementById('character-selection');
                characterSelection.style.display = 'block';
                pacmanStartButton.style.display = 'none';
            }
        }
    });
    
    // Character Selection Handlers
    document.getElementById('select-chicken').addEventListener('click', () => {
        playerCharacter = 'chicken';
        characterSelected = true;
        startGameWithCharacter();
    });
    
    document.getElementById('select-fox').addEventListener('click', () => {
        playerCharacter = 'fox';
        characterSelected = true;
        startGameWithCharacter();
    });
    
    // Add hover effects for character selection
    document.getElementById('select-chicken').addEventListener('mouseenter', function() {
        this.style.transform = 'scale(1.05)';
        this.style.boxShadow = '0 8px 20px rgba(76, 175, 80, 0.4)';
    });
    document.getElementById('select-chicken').addEventListener('mouseleave', function() {
        this.style.transform = 'scale(1)';
        this.style.boxShadow = 'none';
    });
    
    document.getElementById('select-fox').addEventListener('mouseenter', function() {
        this.style.transform = 'scale(1.05)';
        this.style.boxShadow = '0 8px 20px rgba(255, 107, 53, 0.4)';
    });
    document.getElementById('select-fox').addEventListener('mouseleave', function() {
        this.style.transform = 'scale(1)';
        this.style.boxShadow = 'none';
    });
    
    function startGameWithCharacter() {
        const characterSelection = document.getElementById('character-selection');
        characterSelection.style.display = 'none';
        
        // Update game title based on character
        const gameTitle = document.querySelector('#pacman-container h2');
        if (playerCharacter === 'fox') {
            gameTitle.textContent = 'ü¶ä Fox Hunt Mode';
            gameTitle.style.color = '#ff6b35';
        } else {
            gameTitle.textContent = 'Chicken vs. Foxes Maze';
            gameTitle.style.color = '';
        }
        
        // Remove next level button if it exists
        if (nextLevelButton) {
            try {
                document.body.removeChild(nextLevelButton);
            } catch (e) {
                console.error('Error removing next level button:', e);
            }
            nextLevelButton = null;
        }
        
        try {
            pacmanGameRunning = true;
            currentLevel = 1;
            allGhostsEliminated = false;
            initPacmanGame(true); // true means reset score and lives
            pacmanGameLoop();
        } catch (error) {
            console.error('Error starting game:', error);
            pacmanGameRunning = false;
            pacmanStartButton.style.display = 'block';
        }
    }
    
    // Minimap dragging functionality with life cost
    const minimapWrapper = document.getElementById('minimap-wrapper');
    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;
    
    minimapWrapper.addEventListener('mousedown', (e) => {
      // Check if game is running and player has lives available
      if (!pacmanGameRunning) {
        return;
      }
      
      if (pacmanLives <= 0) {
        alert('You have no lives left! Game Over.');
        return;
      }
      
      // Deduct a life for moving the minimap
      pacmanLives--;
      pacmanLivesSpan.textContent = pacmanLives;
      
      // Check if this caused game over
      if (pacmanLives <= 0) {
        pacmanGameRunning = false;
        pacmanStartButton.style.display = 'block';
        const levelsCompleted = currentLevel - 1;
        pacmanStartButton.textContent = `Game Over! Score: ${pacmanScore} - Levels Completed: ${levelsCompleted}`;
        alert('You sacrificed your last life! Game Over.');
        return;
      }
      
      isDragging = true;
      offsetX = e.clientX - minimapWrapper.getBoundingClientRect().left;
      offsetY = e.clientY - minimapWrapper.getBoundingClientRect().top;
      minimapWrapper.style.cursor = 'grabbing';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const newX = e.clientX - offsetX;
        const newY = e.clientY - offsetY;
        minimapWrapper.style.left = newX + 'px';
        minimapWrapper.style.top = newY + 'px';
        minimapWrapper.style.right = 'auto';
        minimapWrapper.style.transform = 'translateY(0)';
      }
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
      minimapWrapper.style.cursor = 'move';
    });
    
    // Pro Tip button functionality
    const proTipButton = document.getElementById('pro-tip-button');
    const proTipDisplay = document.getElementById('pro-tip-display');
    
    const proTips = [
      "üéØ Ghost foxes (purple) can pass through purple walls on the minimap!",
      "‚ö° Speed power-ups are placed far from foxes - use them to escape danger!",
      "üõ°Ô∏è Shield power-ups are near fox clusters - grab them to fight back!",
      "‚ùÑÔ∏è Freeze power-ups are in pellet-rich areas - maximize your collection time!",
      "üëë Boss foxes appear every 3 levels and have special dash attacks!",
      "üåæ Power pellets (wheat) let you eat foxes for bonus points - chain them for multipliers!",
      "üí∞ You get an extra life at every 10,000 points - high scores = more lives!",
      "üó∫Ô∏è The minimap costs 1 life to move - position it strategically at the start!",
      "ü¶ä Regular foxes turn blue and run away when you eat a power pellet!",
      "‚è±Ô∏è You have 2 minutes for ALL levels - speed is key to beating multiple levels!",
      "‚ù§Ô∏è Heart pellets give you an extra life - they're worth more than points!",
      "üèÉ Corner turns are faster than gradual curves - master sharp movements!",
      "üëÅÔ∏è Watch the minimap to see fox positions and plan your escape routes!",
      "üé™ Lead foxes in circles around walls to buy time and collect pellets!",
      "üåü Combo kills during power mode give exponential points - 200, 400, 800, 1600!"
    ];
    
    let usedTips = [];
    
    proTipButton.addEventListener('click', () => {
      // Check if game is running
      if (!pacmanGameRunning) {
        alert('Start the game first to get Pro Tips!');
        return;
      }
      
      // Check if player has lives
      if (pacmanLives <= 0) {
        alert('You have no lives left!');
        return;
      }
      
      // Deduct a life
      pacmanLives--;
      pacmanLivesSpan.textContent = pacmanLives;
      
      // Check if this caused game over
      if (pacmanLives <= 0) {
        pacmanGameRunning = false;
        pacmanStartButton.style.display = 'block';
        const levelsCompleted = currentLevel - 1;
        pacmanStartButton.textContent = `Game Over! Score: ${pacmanScore} - Levels Completed: ${levelsCompleted}`;
        alert('You spent your last life on a tip! Game Over.');
        return;
      }
      
      // Reset used tips if we've shown them all
      if (usedTips.length >= proTips.length) {
        usedTips = [];
      }
      
      // Get a random tip that hasn't been shown recently
      let availableTips = proTips.filter((tip, index) => !usedTips.includes(index));
      let randomIndex = Math.floor(Math.random() * availableTips.length);
      let selectedTip = availableTips[randomIndex];
      let originalIndex = proTips.indexOf(selectedTip);
      usedTips.push(originalIndex);
      
      // Display the tip
      proTipDisplay.innerHTML = `<strong>üí° Pro Tip:</strong> ${selectedTip}`;
      proTipDisplay.style.display = 'block';
      
      // Auto-hide after 15 seconds
      setTimeout(() => {
        proTipDisplay.style.display = 'none';
      }, 15000);
    });
    
    // Setup virtual arrow controls for mobile
    function setupVirtualControls() {
        const arrowUp = document.getElementById('arrow-up');
        const arrowDown = document.getElementById('arrow-down');
        const arrowLeft = document.getElementById('arrow-left');
        const arrowRight = document.getElementById('arrow-right');
        
        // Helper function to handle direction changes
        function handleDirectionChange(direction) {
            if (pacmanContainer.classList.contains('active') && pacmanGameRunning) {
                if (playerCharacter === 'chicken') {
                    // Control the chicken
                    switch(direction) {
                        case 'up':
                            pacmanDirection = { x: 0, y: -1 };
                            break;
                        case 'down':
                            pacmanDirection = { x: 0, y: 1 };
                            break;
                        case 'left':
                            pacmanDirection = { x: -1, y: 0 };
                            break;
                        case 'right':
                            pacmanDirection = { x: 1, y: 0 };
                            break;
                    }
                } else {
                    // Control ALL player foxes (entire pack moves together)
                    if (ghosts.length > 0) {
                        let newDirection;
                        switch(direction) {
                            case 'up':
                                newDirection = { x: 0, y: -1 };
                                break;
                            case 'down':
                                newDirection = { x: 0, y: 1 };
                                break;
                            case 'left':
                                newDirection = { x: -1, y: 0 };
                                break;
                            case 'right':
                                newDirection = { x: 1, y: 0 };
                                break;
                        }
                        
                        // Apply direction to ALL player foxes
                        if (newDirection) {
                            ghosts.forEach(ghost => {
                                if (ghost.isPlayer) {
                                    ghost.direction = { ...newDirection };
                                }
                            });
                        }
                    }
                }
            }
        }
        
        // Add touch event listeners to each button
        // Using both touchstart and mousedown for better compatibility
        arrowUp.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling
            handleDirectionChange('up');
        });
        arrowUp.addEventListener('mousedown', () => handleDirectionChange('up'));
        
        arrowDown.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleDirectionChange('down');
        });
        arrowDown.addEventListener('mousedown', () => handleDirectionChange('down'));
        
        arrowLeft.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleDirectionChange('left');
        });
        arrowLeft.addEventListener('mousedown', () => handleDirectionChange('left'));
        
        arrowRight.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleDirectionChange('right');
        });
        arrowRight.addEventListener('mousedown', () => handleDirectionChange('right'));
    }
    
    // Initialize virtual controls
    setupVirtualControls();
    
    // Keyboard controls
    window.addEventListener('keydown', (e) => {
        // Only process keys if the Pac-Man game is active and running
        if (pacmanContainer.classList.contains('active') && pacmanGameRunning) {
            if (playerCharacter === 'chicken') {
                // Control the chicken
                switch(e.key) {
                    case 'ArrowUp':
                        pacmanDirection = { x: 0, y: -1 };
                        break;
                    case 'ArrowDown':
                        pacmanDirection = { x: 0, y: 1 };
                        break;
                    case 'ArrowLeft':
                        pacmanDirection = { x: -1, y: 0 };
                        break;
                    case 'ArrowRight':
                        pacmanDirection = { x: 1, y: 0 };
                        break;
                }
            } else {
                // Control ALL player foxes (entire pack moves together)
                if (ghosts.length > 0) {
                    let newDirection;
                    switch(e.key) {
                        case 'ArrowUp':
                            newDirection = { x: 0, y: -1 };
                            break;
                        case 'ArrowDown':
                            newDirection = { x: 0, y: 1 };
                            break;
                        case 'ArrowLeft':
                            newDirection = { x: -1, y: 0 };
                            break;
                        case 'ArrowRight':
                            newDirection = { x: 1, y: 0 };
                            break;
                    }
                    
                    // Apply direction to ALL player foxes
                    if (newDirection) {
                        ghosts.forEach(ghost => {
                            if (ghost.isPlayer) {
                                ghost.direction = { ...newDirection };
                            }
                        });
                    }
                }
            }
        }
    });
    
    // Initialize Pac-Man game when the page loads
    initPacmanGame();
  </script>
</body>
</html>